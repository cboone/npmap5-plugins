(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ArcGisRestSource = factory());
})(this, (function () { 'use strict';

  /* @preserve
  * @terraformer/arcgis - v2.1.1 - MIT
  * Copyright (c) 2012-2022 Environmental Systems Research Institute, Inc.
  * Tue Aug 02 2022 14:23:48 GMT-0700 (Pacific Daylight Time)
  */
  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {
    var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
    var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
    var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

    if (uB !== 0) {
      var ua = uaT / uB;
      var ub = ubT / uB;

      if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return true;
      }
    }

    return false;
  };
  var coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {
    var contains = false;

    for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
      if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
        contains = !contains;
      }
    }

    return contains;
  };
  var pointsEqual = function pointsEqual(a, b) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  };
  var arrayIntersectsArray = function arrayIntersectsArray(a, b) {
    for (var i = 0; i < a.length - 1; i++) {
      for (var j = 0; j < b.length - 1; j++) {
        if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
          return true;
        }
      }
    }

    return false;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var closeRing = function closeRing(coordinates) {
    if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
      coordinates.push(coordinates[0]);
    }

    return coordinates;
  }; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
  // or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
  // points-are-in-clockwise-order

  var ringIsClockwise = function ringIsClockwise(ringToTest) {
    var total = 0;
    var i = 0;
    var rLength = ringToTest.length;
    var pt1 = ringToTest[i];
    var pt2;

    for (i; i < rLength - 1; i++) {
      pt2 = ringToTest[i + 1];
      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
      pt1 = pt2;
    }

    return total >= 0;
  }; // This function ensures that rings are oriented in the right directions
  // from http://jsperf.com/cloning-an-object/2

  var shallowClone = function shallowClone(obj) {
    var target = {};

    for (var i in obj) {
      // both arcgis attributes and geojson props are just hardcoded keys
      if (obj.hasOwnProperty(i)) {
        // eslint-disable-line no-prototype-builtins
        target[i] = obj[i];
      }
    }

    return target;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */

  var coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {
    var intersects = arrayIntersectsArray(outer, inner);
    var contains = coordinatesContainPoint(outer, inner[0]);

    if (!intersects && contains) {
      return true;
    }

    return false;
  }; // do any polygons in this array contain any other polygons in this array?
  // used for checking for holes in arcgis rings


  var convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {
    var outerRings = [];
    var holes = [];
    var x; // iterator

    var outerRing; // current outer ring being evaluated

    var hole; // current hole being evaluated
    // for each ring

    for (var r = 0; r < rings.length; r++) {
      var ring = closeRing(rings[r].slice(0));

      if (ring.length < 4) {
        continue;
      } // is this ring an outer ring? is it clockwise?


      if (ringIsClockwise(ring)) {
        var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance

        outerRings.push(polygon); // push to outer rings
      } else {
        holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance
      }
    }

    var uncontainedHoles = []; // while there are holes left...

    while (holes.length) {
      // pop a hole off out stack
      hole = holes.pop(); // loop over all outer rings and see if they contain our hole.

      var contained = false;

      for (x = outerRings.length - 1; x >= 0; x--) {
        outerRing = outerRings[x][0];

        if (coordinatesContainCoordinates(outerRing, hole)) {
          // the hole is contained push it into our polygon
          outerRings[x].push(hole);
          contained = true;
          break;
        }
      } // ring is not contained in any outer ring
      // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320


      if (!contained) {
        uncontainedHoles.push(hole);
      }
    } // if we couldn't match any holes using contains we can try intersects...


    while (uncontainedHoles.length) {
      // pop a hole off out stack
      hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.

      var intersects = false;

      for (x = outerRings.length - 1; x >= 0; x--) {
        outerRing = outerRings[x][0];

        if (arrayIntersectsArray(outerRing, hole)) {
          // the hole is contained push it into our polygon
          outerRings[x].push(hole);
          intersects = true;
          break;
        }
      }

      if (!intersects) {
        outerRings.push([hole.reverse()]);
      }
    }

    if (outerRings.length === 1) {
      return {
        type: 'Polygon',
        coordinates: outerRings[0]
      };
    } else {
      return {
        type: 'MultiPolygon',
        coordinates: outerRings
      };
    }
  };

  var getId = function getId(attributes, idAttribute) {
    var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {
        return attributes[key];
      }
    }

    throw Error('No valid id attribute found');
  };

  var arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {
    var geojson = {};

    if (arcgis.features) {
      geojson.type = 'FeatureCollection';
      geojson.features = [];

      for (var i = 0; i < arcgis.features.length; i++) {
        geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));
      }
    }

    if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {
      geojson.type = 'Point';
      geojson.coordinates = [arcgis.x, arcgis.y];

      if (typeof arcgis.z === 'number') {
        geojson.coordinates.push(arcgis.z);
      }
    }

    if (arcgis.points) {
      geojson.type = 'MultiPoint';
      geojson.coordinates = arcgis.points.slice(0);
    }

    if (arcgis.paths) {
      if (arcgis.paths.length === 1) {
        geojson.type = 'LineString';
        geojson.coordinates = arcgis.paths[0].slice(0);
      } else {
        geojson.type = 'MultiLineString';
        geojson.coordinates = arcgis.paths.slice(0);
      }
    }

    if (arcgis.rings) {
      geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
    }

    if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {
      geojson.type = 'Polygon';
      geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
    }

    if (arcgis.geometry || arcgis.attributes) {
      geojson.type = 'Feature';
      geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;
      geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;

      if (arcgis.attributes) {
        try {
          geojson.id = getId(arcgis.attributes, idAttribute);
        } catch (err) {// don't set an id
        }
      }
    } // if no valid geometry was encountered


    if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
      geojson.geometry = null;
    }

    if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
      console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));
    }

    return geojson;
  };

  /* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
   * Apache-2.0 */
  // outer rings are clockwise, holes are counterclockwise
  // used for converting GeoJSON Polygons to ArcGIS Polygons

  var orientRings = function orientRings(poly) {
    var output = [];
    var polygon = poly.slice(0);
    var outerRing = closeRing(polygon.shift().slice(0));

    if (outerRing.length >= 4) {
      if (!ringIsClockwise(outerRing)) {
        outerRing.reverse();
      }

      output.push(outerRing);

      for (var i = 0; i < polygon.length; i++) {
        var hole = closeRing(polygon[i].slice(0));

        if (hole.length >= 4) {
          if (ringIsClockwise(hole)) {
            hole.reverse();
          }

          output.push(hole);
        }
      }
    }

    return output;
  }; // This function flattens holes in multipolygons to one array of polygons
  // used for converting GeoJSON Polygons to ArcGIS Polygons


  var flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {
    var output = [];

    for (var i = 0; i < rings.length; i++) {
      var polygon = orientRings(rings[i]);

      for (var x = polygon.length - 1; x >= 0; x--) {
        var ring = polygon[x].slice(0);
        output.push(ring);
      }
    }

    return output;
  };

  var geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {
    idAttribute = idAttribute || 'OBJECTID';
    var spatialReference = {
      wkid: 4326
    };
    var result = {};
    var i;

    switch (geojson.type) {
      case 'Point':
        result.x = geojson.coordinates[0];
        result.y = geojson.coordinates[1];

        if (geojson.coordinates[2] != null) {
          result.z = geojson.coordinates[2];
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiPoint':
        result.points = geojson.coordinates.slice(0);

        if (geojson.coordinates[0][2] != null) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'LineString':
        result.paths = [geojson.coordinates.slice(0)];

        if (geojson.coordinates[0][2] != null) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiLineString':
        result.paths = geojson.coordinates.slice(0);

        if (geojson.coordinates[0][0][2] != null) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'Polygon':
        result.rings = orientRings(geojson.coordinates.slice(0));

        if (geojson.coordinates[0][0][2] != null) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'MultiPolygon':
        result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));

        if (geojson.coordinates[0][0][0][2] != null) {
          result.hasZ = true;
        }

        result.spatialReference = spatialReference;
        break;

      case 'Feature':
        if (geojson.geometry) {
          result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);
        }

        result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};

        if (geojson.id) {
          result.attributes[idAttribute] = geojson.id;
        }

        break;

      case 'FeatureCollection':
        result = [];

        for (i = 0; i < geojson.features.length; i++) {
          result.push(geojsonToArcGIS(geojson.features[i], idAttribute));
        }

        break;

      case 'GeometryCollection':
        result = [];

        for (i = 0; i < geojson.geometries.length; i++) {
          result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));
        }

        break;
    }

    return result;
  };

  var WorkerClass = null;

  try {
      var WorkerThreads =
          typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||
          typeof __non_webpack_require__ === 'function' && __non_webpack_require__('worker_threads') ||
          typeof require === 'function' && require('worker_threads');
      WorkerClass = WorkerThreads.Worker;
  } catch(e) {} // eslint-disable-line

  function decodeBase64$1(base64, enableUnicode) {
      return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');
  }

  function createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {
      var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
      var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
      var source = decodeBase64$1(base64, enableUnicode);
      var start = source.indexOf('\n', 10) + 1;
      var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
      return function WorkerFactory(options) {
          return new WorkerClass(body, Object.assign({}, options, { eval: true }));
      };
  }

  function decodeBase64(base64, enableUnicode) {
      var binaryString = atob(base64);
      if (enableUnicode) {
          var binaryView = new Uint8Array(binaryString.length);
          for (var i = 0, n = binaryString.length; i < n; ++i) {
              binaryView[i] = binaryString.charCodeAt(i);
          }
          return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
      }
      return binaryString;
  }

  function createURL(base64, sourcemapArg, enableUnicodeArg) {
      var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
      var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
      var source = decodeBase64(base64, enableUnicode);
      var start = source.indexOf('\n', 10) + 1;
      var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
      var blob = new Blob([body], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
  }

  function createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {
      var url;
      return function WorkerFactory(options) {
          url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
          return new Worker(url, options);
      };
  }

  var kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

  function isNodeJS() {
      return kIsNodeJS;
  }

  function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
      if (isNodeJS()) {
          return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);
      }
      return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);
  }

  var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAndXNlIHN0cmljdCc7CgogIGNvbnN0IGVhcnRoQ2lyY3VtZmVyZW5jZSA9IDQwMDc1MDE2LjY4NTU3ODQ5Ow0KICAvKioNCiAgICAqIENvbnZlcnRzIGEgd2VibWVyY2F0b3IgeCx5IHRvIFdHUzg0IGxuZyxsYXQNCiAgICAqIEBwYXJhbSB4DQogICAgKiBAcGFyYW0geQ0KICAgICogQHJldHVybnMgTG5nTG5nTGlrZQ0KICAgICovDQogIGZ1bmN0aW9uIHRvV0dTODQoeCwgeSkgew0KICAgICAgLy8gQ29udmVydCB0aGUgbGF0IGxuZw0KICAgICAgY29uc3Qgd2dzTG5nID0geCAqIDE4MCAvIChlYXJ0aENpcmN1bWZlcmVuY2UgLyAyKTsNCiAgICAgIC8vIHRoYW5rcyBtYWdpY2hpbSBAIGdpdGh1YiBmb3IgdGhlIGNvcnJlY3Rpb24NCiAgICAgIGNvbnN0IHdnc0xhdCA9IE1hdGguYXRhbihNYXRoLmV4cCh5ICogTWF0aC5QSSAvIChlYXJ0aENpcmN1bWZlcmVuY2UgLyAyKSkpICogMzYwIC8gTWF0aC5QSSAtIDkwOw0KICAgICAgcmV0dXJuIHsgbG5nOiB3Z3NMbmcsIGxhdDogd2dzTGF0IH07DQogIH0NCiAgOw0KICAvKioNCiAgICogQ29udmVydHMgYSBXR1M4NCBsbmcsbGF0IHRvIHdlYm1lcmNhdG9yIHgseQ0KICAgKiBAcGFyYW0gbG5nDQogICAqIEBwYXJhbSBsYXQNCiAgICogQHJldHVybnMge3g6IG51bWJlciwgeTogbnVtYmVyfQ0KICAgKi8NCiAgZnVuY3Rpb24gZnJvbVdHUzg0KGxuZywgbGF0KSB7DQogICAgICAvLyBDYWxjdWxhdGUgdGhlIHdlYiBtZXJjYXRvciBYIGFuZCBZDQogICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9vbmRlcmFsdGludGFzLzY2NDk1MjENCiAgICAgIGNvbnN0IHdteCA9IGxuZyAqIChlYXJ0aENpcmN1bWZlcmVuY2UgLyAyKSAvIDE4MDsNCiAgICAgIGxldCB3bXkgPSBNYXRoLmxvZyhNYXRoLnRhbigoOTAgKyBsYXQpICogTWF0aC5QSSAvIDM2MCkpIC8gKE1hdGguUEkgLyAxODApOw0KICAgICAgd215ID0gd215ICogKGVhcnRoQ2lyY3VtZmVyZW5jZSAvIDIpIC8gMTgwOw0KICAgICAgcmV0dXJuIHsgeDogd214LCB5OiB3bXkgfTsNCiAgfQ0KICA7DQogIC8qKg0KICAgKiBUYWtlcyBhIHpvb20sIHJldHVybnMgV2ViTWVyY2F0b3IgTWV0ZXJzIFBlciBQaXhlbA0KICAgKiBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvcG9zdGdpcy12dC11dGlsL2Jsb2IvbWFzdGVyL3NyYy9aUmVzLnNxbA0KICAgKiBAcGFyYW0gem9vbQ0KICAgKiBAcGFyYW0gdGlsZVNpemUgaXMgb3B0aW9uYWwsIGRlZmF1bHQgaXMgMjU2IChmb3IgMjU2eDI1NiB0aWxlcykNCiAgICogQHJldHVybnMgbnVtYmVyDQogICAqLw0KICBmdW5jdGlvbiBtZXRlcnNQZXJQaXhlbCh6b29tLCB0aWxlU2l6ZSA9IDI1Nikgew0KICAgICAgcmV0dXJuIGVhcnRoQ2lyY3VtZmVyZW5jZSAvICh0aWxlU2l6ZSAqICgxIDw8IHpvb20pKTsNCiAgfQoKICBjb25zdCB3ZWJNZXJjYXRvckNvZGVzID0gWycxMDIxMDAnLCAnOTAwOTEzJywgJzM4NTcnLCAnMzU4NycsICc1NDAwNCcsICc0MTAwMScsICcxMDIxMTMnLCAnMzc4NSddOw0KICBmdW5jdGlvbiBnZXRFc3JpQm91bmRpbmdCb3gobG5nTGF0QmJveCkgew0KICAgICAgY29uc3Qgc3cgPSBbTWF0aC5taW4obG5nTGF0QmJveFswXSwgbG5nTGF0QmJveFsyXSksIE1hdGgubWluKGxuZ0xhdEJib3hbMV0sIGxuZ0xhdEJib3hbM10pXTsNCiAgICAgIGNvbnN0IG5lID0gW01hdGgubWF4KGxuZ0xhdEJib3hbMF0sIGxuZ0xhdEJib3hbMl0pLCBNYXRoLm1heChsbmdMYXRCYm94WzFdLCBsbmdMYXRCYm94WzNdKV07DQogICAgICBsZXQgc3dYWSA9IGZyb21XR1M4NChzd1swXSwgc3dbMV0pOw0KICAgICAgbGV0IG5lWFkgPSBmcm9tV0dTODQobmVbMF0sIG5lWzFdKTsNCiAgICAgIHJldHVybiB7DQogICAgICAgICAgJ3R5cGUnOiAnZXh0ZW50JywNCiAgICAgICAgICAneG1pbic6IHN3WFkueCwNCiAgICAgICAgICAneW1pbic6IHN3WFkueSwNCiAgICAgICAgICAneG1heCc6IG5lWFkueCwNCiAgICAgICAgICAneW1heCc6IG5lWFkueSwNCiAgICAgICAgICAnc3BhdGlhbFJlZmVyZWNlJzogew0KICAgICAgICAgICAgICAnbGF0ZXN0V2tpZCc6IDEwMjEwMCwNCiAgICAgICAgICAgICAgJ3draWQnOiAzODU3DQogICAgICAgICAgfQ0KICAgICAgfTsNCiAgfQ0KICA7DQogIGZ1bmN0aW9uIHF1YW50aXphdGlvblBhcmFtZXRlcnModGlsZVpvb21MZXZlbCwgdGlsZVNpemUgPSAyNTYpIHsNCiAgICAgIHJldHVybiB7DQogICAgICAgICAgbW9kZTogJ3ZpZXcnLA0KICAgICAgICAgIG9yaWdpblBvc2l0aW9uOiAndXBwZXJMZWZ0JywNCiAgICAgICAgICB0b2xlcmFuY2U6IG1ldGVyc1BlclBpeGVsKHRpbGVab29tTGV2ZWwsIHRpbGVTaXplKSwNCiAgICAgICAgICBleHRlbnQ6IGdldEVzcmlCb3VuZGluZ0JveChbLTE4MC4wLCAtODUuMDYsIDE4MCwgODUuMDZdKQ0KICAgICAgfTsNCiAgfQ0KICA7DQogIGZ1bmN0aW9uIG1lcmdlUmluZ3MocmluZ3NYLCByaW5nc1ksIHNyaWQpIHsNCiAgICAgIGNvbnN0IHJlcHJvamVjdCA9ICh4LCB5KSA9PiB7DQogICAgICAgICAgY29uc3QgeHkgPSB0b1dHUzg0KHgsIHkpOw0KICAgICAgICAgIHJldHVybiBbeHkubG5nLCB4eS5sYXRdOw0KICAgICAgfTsNCiAgICAgIGlmICh3ZWJNZXJjYXRvckNvZGVzLmluZGV4T2Yoc3JpZCkgPiAtMSkgew0KICAgICAgICAgIHJldHVybiByaW5nc1gubWFwKChyaW5nLCBpKSA9PiByaW5nLm1hcCgoeCwgaikgPT4gcmVwcm9qZWN0KHgsIHJpbmdzWVtpXVtqXSkpKTsNCiAgICAgIH0NCiAgICAgIGVsc2Ugew0KICAgICAgICAgIHJldHVybiByaW5nc1gubWFwKChyaW5nLCBpKSA9PiByaW5nLm1hcCgoeCwgaikgPT4gW3gsIHJpbmdzWVtpXVtqXV0pKTsNCiAgICAgIH0NCiAgfQ0KICA7DQogIGZ1bmN0aW9uIGRlWmlnWmFnKHZhbHVlcywgc3BsaXRzLCBzY2FsZSwgaW5pdGlhbE9mZnNldCwgdXBwZXJMZWZ0T3JpZ2luKSB7DQogICAgICByZXR1cm4gc3BsaXRzLm1hcCgoc3BsaXQsIGkpID0+IHsNCiAgICAgICAgICBsZXQgbGFzdFZhbHVlID0gMDsNCiAgICAgICAgICByZXR1cm4gQXJyYXkoc3BsaXQpLmZpbGwodW5kZWZpbmVkKS5tYXAoKF8sIGopID0+IHsNCiAgICAgICAgICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBzcGxpdHMucmVkdWNlKChhLCB2LCBpZHgpID0+IGEgKz0gKGlkeCA8IGkgPyB2IDogMCksIDApOw0KICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZU9mZnNldCArIGpdOw0KICAgICAgICAgICAgICBjb25zdCBzaWduID0gdXBwZXJMZWZ0T3JpZ2luID8gLTEgOiAxOw0KICAgICAgICAgICAgICBsZXQgcmV0dXJuVmFsdWU7DQogICAgICAgICAgICAgIGlmIChqID09PSAwKSB7DQogICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICh2YWx1ZSAqIHNpZ24pICsgKGluaXRpYWxPZmZzZXQgLyBzY2FsZSk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICh2YWx1ZSAqIHNpZ24pICsgbGFzdFZhbHVlOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHJldHVyblZhbHVlOw0KICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7DQogICAgICAgICAgfSkubWFwKCh2KSA9PiB2ICogc2NhbGUpOw0KICAgICAgfSk7DQogIH0NCiAgY2xhc3MgRGVaaWdaYWdKU09OIHsNCiAgICAgIGNvbnN0cnVjdG9yKGZlYXR1cmVzLCB0cmFuc2Zvcm0sIGdlb21ldHJ5VHlwZSkgew0KICAgICAgICAgIHRoaXMuc3JpZCA9ICczODU3JzsNCiAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7DQogICAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07DQogICAgICAgICAgdGhpcy5nZW9tZXRyeVR5cGUgPSBnZW9tZXRyeVR5cGU7DQogICAgICB9DQogICAgICBhc3luYyBjb252ZXJ0KCkgew0KICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzLm1hcChmZWF0dXJlID0+IHsNCiAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeSA9IHRoaXMuY29udmVydEdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnkpOw0KICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTsNCiAgICAgICAgICB9KTsNCiAgICAgIH0NCiAgICAgIGNvbnZlcnRHZW9tZXRyeShnZW9tZXRyeSkgew0KICAgICAgICAgIGNvbnN0IGNvdW50cyA9IFtdOw0KICAgICAgICAgIGNvbnN0IHggPSBbXTsNCiAgICAgICAgICBjb25zdCB5ID0gW107DQogICAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnlUeXBlID09PSAnZXNyaUdlb21ldHJ5UG9pbnQnKSB7DQogICAgICAgICAgICAgIGNvdW50cy5wdXNoKDEpOw0KICAgICAgICAgICAgICB4LnB1c2goZ2VvbWV0cnkueCk7DQogICAgICAgICAgICAgIHkucHVzaChnZW9tZXRyeS55KTsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAodGhpcy5nZW9tZXRyeVR5cGUgPT09ICdlc3JpR2VvbWV0cnlNdWx0aXBvaW50Jykgew0KICAgICAgICAgICAgICBnZW9tZXRyeS5wb2ludHMuZm9yRWFjaChwID0+IHsNCiAgICAgICAgICAgICAgICAgIGNvdW50cy5wdXNoKDEpOw0KICAgICAgICAgICAgICAgICAgeC5wdXNoKHBbMF0pOw0KICAgICAgICAgICAgICAgICAgeS5wdXNoKHBbMV0pOw0KICAgICAgICAgICAgICB9KTsNCiAgICAgICAgICB9DQogICAgICAgICAgZWxzZSBpZiAodGhpcy5nZW9tZXRyeVR5cGUgPT09ICdlc3JpR2VvbWV0cnlQb2x5bGluZScpIHsNCiAgICAgICAgICAgICAgZ2VvbWV0cnkucGF0aHMuZm9yRWFjaChsID0+IHsNCiAgICAgICAgICAgICAgICAgIGNvdW50cy5wdXNoKGwubGVuZ3RoKTsNCiAgICAgICAgICAgICAgICAgIGwuZm9yRWFjaChwb3NpdGlvbiA9PiB7DQogICAgICAgICAgICAgICAgICAgICAgeC5wdXNoKHBvc2l0aW9uWzBdKTsNCiAgICAgICAgICAgICAgICAgICAgICB5LnB1c2gocG9zaXRpb25bMV0pOw0KICAgICAgICAgICAgICAgICAgfSk7DQogICAgICAgICAgICAgIH0pOw0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmICh0aGlzLmdlb21ldHJ5VHlwZSA9PT0gJ2VzcmlHZW9tZXRyeVBvbHlnb24nKSB7DQogICAgICAgICAgICAgIGdlb21ldHJ5LnJpbmdzLmZvckVhY2gocG9seSA9PiB7DQogICAgICAgICAgICAgICAgICBjb3VudHMucHVzaChwb2x5Lmxlbmd0aCk7DQogICAgICAgICAgICAgICAgICBwb2x5LmZvckVhY2gocG9zaXRpb24gPT4gew0KICAgICAgICAgICAgICAgICAgICAgIHgucHVzaChwb3NpdGlvblswXSk7DQogICAgICAgICAgICAgICAgICAgICAgeS5wdXNoKHBvc2l0aW9uWzFdKTsNCiAgICAgICAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgICB9KTsNCiAgICAgICAgICB9DQogICAgICAgICAgLy8gZGV6aWd6YWcgdGhlIHJpbmdzLCBhbmQgbWVyZ2UgKyByZXByb2plY3QgdGhlbQ0KICAgICAgICAgIGNvbnN0IHJpbmdzWCA9IGRlWmlnWmFnKHgsIGNvdW50cywgdGhpcy50cmFuc2Zvcm0uc2NhbGVbMF0sIHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0ZVswXSwgZmFsc2UpOw0KICAgICAgICAgIGNvbnN0IHJpbmdzWSA9IGRlWmlnWmFnKHksIGNvdW50cywgdGhpcy50cmFuc2Zvcm0uc2NhbGVbMV0sIHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0ZVsxXSwgdGhpcy50cmFuc2Zvcm0ub3JpZ2luUG9zaXRpb24gPT09ICd1cHBlckxlZnQnKTsNCiAgICAgICAgICAvLyBNZXJnZSB0aGUgcmluZ3MNCiAgICAgICAgICBjb25zdCByaW5ncyA9IG1lcmdlUmluZ3MocmluZ3NYLCByaW5nc1ksIHRoaXMuc3JpZCk7DQogICAgICAgICAgbGV0IG5ld0dlb21ldHJ5ID0ge307DQogICAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnlUeXBlID09PSAnZXNyaUdlb21ldHJ5UG9pbnQnKSB7DQogICAgICAgICAgICAgIG5ld0dlb21ldHJ5ID0geyAneCc6IHJpbmdzWzBdWzBdWzBdLCAneSc6IHJpbmdzWzBdWzBdWzFdIH07DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2VvbWV0cnlUeXBlID09PSAnZXNyaUdlb21ldHJ5TXVsdGlwb2ludCcpIHsNCiAgICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSB7ICdwb2ludHMnOiByaW5nc1swXSB9Ow0KICAgICAgICAgIH0NCiAgICAgICAgICBlbHNlIGlmICh0aGlzLmdlb21ldHJ5VHlwZSA9PT0gJ2VzcmlHZW9tZXRyeVBvbHlsaW5lJykgew0KICAgICAgICAgICAgICBuZXdHZW9tZXRyeSA9IHsgcGF0aHM6IHJpbmdzIH07DQogICAgICAgICAgfQ0KICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZ2VvbWV0cnlUeXBlID09PSAnZXNyaUdlb21ldHJ5UG9seWdvbicpIHsNCiAgICAgICAgICAgICAgbmV3R2VvbWV0cnkgPSB7IHJpbmdzOiByaW5ncyB9Ow0KICAgICAgICAgIH0NCiAgICAgICAgICByZXR1cm4gbmV3R2VvbWV0cnk7DQogICAgICB9DQogIH0KCiAgJ3VzZSBzdHJpY3QnOyAvLyBjb2RlIGdlbmVyYXRlZCBieSBwYmYgdjMuMi4xDQogIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09DQogIGZ1bmN0aW9uIHByb3RvICgpIHsNCiAgICAgIGxldCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5fcmVhZEZpZWxkLCB7IHZlcnNpb246ICIiLCBxdWVyeVJlc3VsdDogbnVsbCB9LCBlbmQpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmoudmVyc2lvbiA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAyKQ0KICAgICAgICAgICAgICBvYmoucXVlcnlSZXN1bHQgPSBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuUXVlcnlSZXN1bHQucmVhZChwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIud3JpdGUgPSBmdW5jdGlvbiAob2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAob2JqLnZlcnNpb24pDQogICAgICAgICAgICAgIHBiZi53cml0ZVN0cmluZ0ZpZWxkKDEsIG9iai52ZXJzaW9uKTsNCiAgICAgICAgICBpZiAob2JqLnF1ZXJ5UmVzdWx0KQ0KICAgICAgICAgICAgICBwYmYud3JpdGVNZXNzYWdlKDIsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5RdWVyeVJlc3VsdC53cml0ZSwgb2JqLnF1ZXJ5UmVzdWx0KTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuR2VvbWV0cnlUeXBlID0gew0KICAgICAgICAgICJlc3JpR2VvbWV0cnlUeXBlUG9pbnQiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDAsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJlc3JpR2VvbWV0cnlUeXBlTXVsdGlwb2ludCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMSwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlHZW9tZXRyeVR5cGVQb2x5bGluZSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMiwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlHZW9tZXRyeVR5cGVQb2x5Z29uIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAzLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAiZXNyaUdlb21ldHJ5VHlwZU11bHRpcGF0Y2giOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDQsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJlc3JpR2VvbWV0cnlUeXBlTm9uZSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMTI3LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfQ0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZFR5cGUgPSB7DQogICAgICAgICAgImVzcmlGaWVsZFR5cGVTbWFsbEludGVnZXIiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDAsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJlc3JpRmllbGRUeXBlSW50ZWdlciI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMSwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVTaW5nbGUiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDIsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJlc3JpRmllbGRUeXBlRG91YmxlIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAzLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAiZXNyaUZpZWxkVHlwZVN0cmluZyI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVEYXRlIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiA1LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAiZXNyaUZpZWxkVHlwZU9JRCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNiwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVHZW9tZXRyeSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNywNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVCbG9iIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiA4LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAiZXNyaUZpZWxkVHlwZVJhc3RlciI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogOSwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVHVUlEIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAxMCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgImVzcmlGaWVsZFR5cGVHbG9iYWxJRCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMTEsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJlc3JpRmllbGRUeXBlWE1MIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAxMiwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0NCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU1FMVHlwZSA9IHsNCiAgICAgICAgICAic3FsVHlwZUJpZ0ludCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVCaW5hcnkiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDEsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlQml0Ijogew0KICAgICAgICAgICAgICAidmFsdWUiOiAyLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZUNoYXIiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDMsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlRGF0ZSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVEZWNpbWFsIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiA1LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZURvdWJsZSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNiwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVGbG9hdCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogNywNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVHZW9tZXRyeSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogOCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVHVUlEIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiA5LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZUludGVnZXIiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDEwLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZUxvbmdOVmFyY2hhciI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMTEsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlTG9uZ1ZhcmJpbmFyeSI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMTIsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlTG9uZ1ZhcmNoYXIiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDEzLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZU5DaGFyIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAxNCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVOVmFyY2hhciI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMTUsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlT3RoZXIiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDE2LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZVJlYWwiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDE3LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZVNtYWxsSW50Ijogew0KICAgICAgICAgICAgICAidmFsdWUiOiAxOCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVTcWxYbWwiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDE5LA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZVRpbWUiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDIwLA0KICAgICAgICAgICAgICAib3B0aW9ucyI6IHt9DQogICAgICAgICAgfSwNCiAgICAgICAgICAic3FsVHlwZVRpbWVzdGFtcCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMjEsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlVGltZXN0YW1wMiI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMjIsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlVGlueUludCI6IHsNCiAgICAgICAgICAgICAgInZhbHVlIjogMjMsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJzcWxUeXBlVmFyYmluYXJ5Ijogew0KICAgICAgICAgICAgICAidmFsdWUiOiAyNCwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0sDQogICAgICAgICAgInNxbFR5cGVWYXJjaGFyIjogew0KICAgICAgICAgICAgICAidmFsdWUiOiAyNSwNCiAgICAgICAgICAgICAgIm9wdGlvbnMiOiB7fQ0KICAgICAgICAgIH0NCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuUXVhbnRpemVPcmlnaW5Qb3N0aW9uID0gew0KICAgICAgICAgICJ1cHBlckxlZnQiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDAsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9LA0KICAgICAgICAgICJsb3dlckxlZnQiOiB7DQogICAgICAgICAgICAgICJ2YWx1ZSI6IDEsDQogICAgICAgICAgICAgICJvcHRpb25zIjoge30NCiAgICAgICAgICB9DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNwYXRpYWxSZWZlcmVuY2UgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNwYXRpYWxSZWZlcmVuY2UgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TcGF0aWFsUmVmZXJlbmNlLnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNwYXRpYWxSZWZlcmVuY2UuX3JlYWRGaWVsZCwgeyB3a2lkOiAwLCBsYXN0ZXN0V2tpZDogMCwgdmNzV2tpZDogMCwgbGF0ZXN0VmNzV2tpZDogMCwgd2t0OiAiIiB9LCBlbmQpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TcGF0aWFsUmVmZXJlbmNlLl9yZWFkRmllbGQgPSBmdW5jdGlvbiAodGFnLCBvYmosIHBiZikgew0KICAgICAgICAgIGlmICh0YWcgPT09IDEpDQogICAgICAgICAgICAgIG9iai53a2lkID0gcGJmLnJlYWRWYXJpbnQoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5sYXN0ZXN0V2tpZCA9IHBiZi5yZWFkVmFyaW50KCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmoudmNzV2tpZCA9IHBiZi5yZWFkVmFyaW50KCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA0KQ0KICAgICAgICAgICAgICBvYmoubGF0ZXN0VmNzV2tpZCA9IHBiZi5yZWFkVmFyaW50KCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA1KQ0KICAgICAgICAgICAgICBvYmoud2t0ID0gcGJmLnJlYWRTdHJpbmcoKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU3BhdGlhbFJlZmVyZW5jZS53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmoud2tpZCkNCiAgICAgICAgICAgICAgcGJmLndyaXRlVmFyaW50RmllbGQoMSwgb2JqLndraWQpOw0KICAgICAgICAgIGlmIChvYmoubGFzdGVzdFdraWQpDQogICAgICAgICAgICAgIHBiZi53cml0ZVZhcmludEZpZWxkKDIsIG9iai5sYXN0ZXN0V2tpZCk7DQogICAgICAgICAgaWYgKG9iai52Y3NXa2lkKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCgzLCBvYmoudmNzV2tpZCk7DQogICAgICAgICAgaWYgKG9iai5sYXRlc3RWY3NXa2lkKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCg0LCBvYmoubGF0ZXN0VmNzV2tpZCk7DQogICAgICAgICAgaWYgKG9iai53a3QpDQogICAgICAgICAgICAgIHBiZi53cml0ZVN0cmluZ0ZpZWxkKDUsIG9iai53a3QpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuRmllbGQgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC5fcmVhZEZpZWxkLCB7IG5hbWU6ICIiLCBmaWVsZFR5cGU6IDAsIGFsaWFzOiAiIiwgc3FsVHlwZTogMCwgZG9tYWluOiAiIiwgZGVmYXVsdFZhbHVlOiAiIiB9LCBlbmQpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmoubmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAyKQ0KICAgICAgICAgICAgICBvYmouZmllbGRUeXBlID0gcGJmLnJlYWRWYXJpbnQoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDMpDQogICAgICAgICAgICAgIG9iai5hbGlhcyA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA0KQ0KICAgICAgICAgICAgICBvYmouc3FsVHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA1KQ0KICAgICAgICAgICAgICBvYmouZG9tYWluID0gcGJmLnJlYWRTdHJpbmcoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDYpDQogICAgICAgICAgICAgIG9iai5kZWZhdWx0VmFsdWUgPSBwYmYucmVhZFN0cmluZygpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmoubmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLm5hbWUpOw0KICAgICAgICAgIGlmIChvYmouZmllbGRUeXBlKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCgyLCBvYmouZmllbGRUeXBlKTsNCiAgICAgICAgICBpZiAob2JqLmFsaWFzKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVTdHJpbmdGaWVsZCgzLCBvYmouYWxpYXMpOw0KICAgICAgICAgIGlmIChvYmouc3FsVHlwZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlVmFyaW50RmllbGQoNCwgb2JqLnNxbFR5cGUpOw0KICAgICAgICAgIGlmIChvYmouZG9tYWluKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVTdHJpbmdGaWVsZCg1LCBvYmouZG9tYWluKTsNCiAgICAgICAgICBpZiAob2JqLmRlZmF1bHRWYWx1ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoNiwgb2JqLmRlZmF1bHRWYWx1ZSk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlZhbHVlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5WYWx1ZSA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlZhbHVlLnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlZhbHVlLl9yZWFkRmllbGQsIHsgc3RyaW5nX3ZhbHVlOiAiIiwgdmFsdWVfdHlwZTogbnVsbCwgZmxvYXRfdmFsdWU6IDAsIGRvdWJsZV92YWx1ZTogMCwgc2ludF92YWx1ZTogMCwgdWludF92YWx1ZTogMCwgaW50NjRfdmFsdWU6IDAsIHVpbnQ2NF92YWx1ZTogMCwgc2ludDY0X3ZhbHVlOiAwLCBib29sX3ZhbHVlOiBmYWxzZSB9LCBlbmQpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5WYWx1ZS5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmouc3RyaW5nX3ZhbHVlID0gcGJmLnJlYWRTdHJpbmcoKSwgb2JqLnZhbHVlX3R5cGUgPSAic3RyaW5nX3ZhbHVlIjsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5mbG9hdF92YWx1ZSA9IHBiZi5yZWFkRmxvYXQoKSwgb2JqLnZhbHVlX3R5cGUgPSAiZmxvYXRfdmFsdWUiOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gMykNCiAgICAgICAgICAgICAgb2JqLmRvdWJsZV92YWx1ZSA9IHBiZi5yZWFkRG91YmxlKCksIG9iai52YWx1ZV90eXBlID0gImRvdWJsZV92YWx1ZSI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA0KQ0KICAgICAgICAgICAgICBvYmouc2ludF92YWx1ZSA9IHBiZi5yZWFkU1ZhcmludCgpLCBvYmoudmFsdWVfdHlwZSA9ICJzaW50X3ZhbHVlIjsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDUpDQogICAgICAgICAgICAgIG9iai51aW50X3ZhbHVlID0gcGJmLnJlYWRWYXJpbnQoKSwgb2JqLnZhbHVlX3R5cGUgPSAidWludF92YWx1ZSI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA2KQ0KICAgICAgICAgICAgICBvYmouaW50NjRfdmFsdWUgPSBwYmYucmVhZFZhcmludCh0cnVlKSwgb2JqLnZhbHVlX3R5cGUgPSAiaW50NjRfdmFsdWUiOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gNykNCiAgICAgICAgICAgICAgb2JqLnVpbnQ2NF92YWx1ZSA9IHBiZi5yZWFkVmFyaW50KCksIG9iai52YWx1ZV90eXBlID0gInVpbnQ2NF92YWx1ZSI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA4KQ0KICAgICAgICAgICAgICBvYmouc2ludDY0X3ZhbHVlID0gcGJmLnJlYWRTVmFyaW50KCksIG9iai52YWx1ZV90eXBlID0gInNpbnQ2NF92YWx1ZSI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA5KQ0KICAgICAgICAgICAgICBvYmouYm9vbF92YWx1ZSA9IHBiZi5yZWFkQm9vbGVhbigpLCBvYmoudmFsdWVfdHlwZSA9ICJib29sX3ZhbHVlIjsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuVmFsdWUud3JpdGUgPSBmdW5jdGlvbiAob2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAob2JqLnN0cmluZ192YWx1ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLnN0cmluZ192YWx1ZSk7DQogICAgICAgICAgaWYgKG9iai5mbG9hdF92YWx1ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRmxvYXRGaWVsZCgyLCBvYmouZmxvYXRfdmFsdWUpOw0KICAgICAgICAgIGlmIChvYmouZG91YmxlX3ZhbHVlKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVEb3VibGVGaWVsZCgzLCBvYmouZG91YmxlX3ZhbHVlKTsNCiAgICAgICAgICBpZiAob2JqLnNpbnRfdmFsdWUpDQogICAgICAgICAgICAgIHBiZi53cml0ZVNWYXJpbnRGaWVsZCg0LCBvYmouc2ludF92YWx1ZSk7DQogICAgICAgICAgaWYgKG9iai51aW50X3ZhbHVlKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCg1LCBvYmoudWludF92YWx1ZSk7DQogICAgICAgICAgaWYgKG9iai5pbnQ2NF92YWx1ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlVmFyaW50RmllbGQoNiwgb2JqLmludDY0X3ZhbHVlKTsNCiAgICAgICAgICBpZiAob2JqLnVpbnQ2NF92YWx1ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlVmFyaW50RmllbGQoNywgb2JqLnVpbnQ2NF92YWx1ZSk7DQogICAgICAgICAgaWYgKG9iai5zaW50NjRfdmFsdWUpDQogICAgICAgICAgICAgIHBiZi53cml0ZVNWYXJpbnRGaWVsZCg4LCBvYmouc2ludDY0X3ZhbHVlKTsNCiAgICAgICAgICBpZiAob2JqLmJvb2xfdmFsdWUpDQogICAgICAgICAgICAgIHBiZi53cml0ZUJvb2xlYW5GaWVsZCg5LCBvYmouYm9vbF92YWx1ZSk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeSA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5LnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5Ll9yZWFkRmllbGQsIHsgbGVuZ3RoczogW10sIGNvb3JkczogW10gfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuR2VvbWV0cnkuX3JlYWRGaWVsZCA9IGZ1bmN0aW9uICh0YWcsIG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKHRhZyA9PT0gMikNCiAgICAgICAgICAgICAgcGJmLnJlYWRQYWNrZWRWYXJpbnQob2JqLmxlbmd0aHMpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gMykNCiAgICAgICAgICAgICAgcGJmLnJlYWRQYWNrZWRTVmFyaW50KG9iai5jb29yZHMpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeS53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmoubGVuZ3RocykNCiAgICAgICAgICAgICAgcGJmLndyaXRlUGFja2VkVmFyaW50KDIsIG9iai5sZW5ndGhzKTsNCiAgICAgICAgICBpZiAob2JqLmNvb3JkcykNCiAgICAgICAgICAgICAgcGJmLndyaXRlUGFja2VkU1ZhcmludCgzLCBvYmouY29vcmRzKTsNCiAgICAgIH07DQogICAgICAvLyBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuZXNyaVNoYXBlQnVmZmVyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5lc3JpU2hhcGVCdWZmZXIgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5lc3JpU2hhcGVCdWZmZXIucmVhZCA9IGZ1bmN0aW9uIChwYmYsIGVuZCkgew0KICAgICAgICAgIHJldHVybiBwYmYucmVhZEZpZWxkcyhGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuZXNyaVNoYXBlQnVmZmVyLl9yZWFkRmllbGQsIHsgYnl0ZXM6IG51bGwgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuZXNyaVNoYXBlQnVmZmVyLl9yZWFkRmllbGQgPSBmdW5jdGlvbiAodGFnLCBvYmosIHBiZikgew0KICAgICAgICAgIGlmICh0YWcgPT09IDEpDQogICAgICAgICAgICAgIG9iai5ieXRlcyA9IHBiZi5yZWFkQnl0ZXMoKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuZXNyaVNoYXBlQnVmZmVyLndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai5ieXRlcykNCiAgICAgICAgICAgICAgcGJmLndyaXRlQnl0ZXNGaWVsZCgxLCBvYmouYnl0ZXMpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlID0ge307DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuRmVhdHVyZS5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlLl9yZWFkRmllbGQsIHsgYXR0cmlidXRlczogW10sIGdlb21ldHJ5OiBudWxsLCBjb21wcmVzc2VkX2dlb21ldHJ5OiBudWxsLCBzaGFwZUJ1ZmZlcjogbnVsbCwgY2VudHJvaWQ6IG51bGwgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuRmVhdHVyZS5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmouYXR0cmlidXRlcy5wdXNoKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5WYWx1ZS5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5nZW9tZXRyeSA9IEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeS5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpLCBvYmouY29tcHJlc3NlZF9nZW9tZXRyeSA9ICJnZW9tZXRyeSI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmouc2hhcGVCdWZmZXIgPSBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuZXNyaVNoYXBlQnVmZmVyLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyksIG9iai5jb21wcmVzc2VkX2dlb21ldHJ5ID0gInNoYXBlQnVmZmVyIjsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDQpDQogICAgICAgICAgICAgIG9iai5jZW50cm9pZCA9IEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeS5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlLndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai5hdHRyaWJ1dGVzKQ0KICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKQ0KICAgICAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgxLCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuVmFsdWUud3JpdGUsIG9iai5hdHRyaWJ1dGVzW2ldKTsNCiAgICAgICAgICBpZiAob2JqLmdlb21ldHJ5KQ0KICAgICAgICAgICAgICBwYmYud3JpdGVNZXNzYWdlKDIsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeS53cml0ZSwgb2JqLmdlb21ldHJ5KTsNCiAgICAgICAgICBpZiAob2JqLnNoYXBlQnVmZmVyKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVNZXNzYWdlKDMsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5lc3JpU2hhcGVCdWZmZXIud3JpdGUsIG9iai5zaGFwZUJ1ZmZlcik7DQogICAgICAgICAgaWYgKG9iai5jZW50cm9pZCkNCiAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSg0LCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuR2VvbWV0cnkud3JpdGUsIG9iai5jZW50cm9pZCk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlVuaXF1ZUlkRmllbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlVuaXF1ZUlkRmllbGQgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5VbmlxdWVJZEZpZWxkLnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlVuaXF1ZUlkRmllbGQuX3JlYWRGaWVsZCwgeyBuYW1lOiAiIiwgaXNTeXN0ZW1NYWludGFpbmVkOiBmYWxzZSB9LCBlbmQpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5VbmlxdWVJZEZpZWxkLl9yZWFkRmllbGQgPSBmdW5jdGlvbiAodGFnLCBvYmosIHBiZikgew0KICAgICAgICAgIGlmICh0YWcgPT09IDEpDQogICAgICAgICAgICAgIG9iai5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5pc1N5c3RlbU1haW50YWluZWQgPSBwYmYucmVhZEJvb2xlYW4oKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuVW5pcXVlSWRGaWVsZC53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmoubmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLm5hbWUpOw0KICAgICAgICAgIGlmIChvYmouaXNTeXN0ZW1NYWludGFpbmVkKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVCb29sZWFuRmllbGQoMiwgb2JqLmlzU3lzdGVtTWFpbnRhaW5lZCk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5UHJvcGVydGllcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuR2VvbWV0cnlQcm9wZXJ0aWVzID0ge307DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuR2VvbWV0cnlQcm9wZXJ0aWVzLnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5UHJvcGVydGllcy5fcmVhZEZpZWxkLCB7IHNoYXBlQXJlYUZpZWxkTmFtZTogIiIsIHNoYXBlTGVuZ3RoRmllbGROYW1lOiAiIiwgdW5pdHM6ICIiIH0sIGVuZCk7DQogICAgICB9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5UHJvcGVydGllcy5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmouc2hhcGVBcmVhRmllbGROYW1lID0gcGJmLnJlYWRTdHJpbmcoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5zaGFwZUxlbmd0aEZpZWxkTmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmoudW5pdHMgPSBwYmYucmVhZFN0cmluZygpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeVByb3BlcnRpZXMud3JpdGUgPSBmdW5jdGlvbiAob2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAob2JqLnNoYXBlQXJlYUZpZWxkTmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLnNoYXBlQXJlYUZpZWxkTmFtZSk7DQogICAgICAgICAgaWYgKG9iai5zaGFwZUxlbmd0aEZpZWxkTmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMiwgb2JqLnNoYXBlTGVuZ3RoRmllbGROYW1lKTsNCiAgICAgICAgICBpZiAob2JqLnVuaXRzKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVTdHJpbmdGaWVsZCgzLCBvYmoudW5pdHMpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TZXJ2ZXJHZW5zID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TZXJ2ZXJHZW5zID0ge307DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2VydmVyR2Vucy5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TZXJ2ZXJHZW5zLl9yZWFkRmllbGQsIHsgbWluU2VydmVyR2VuOiAwLCBzZXJ2ZXJHZW46IDAgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2VydmVyR2Vucy5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmoubWluU2VydmVyR2VuID0gcGJmLnJlYWRWYXJpbnQoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5zZXJ2ZXJHZW4gPSBwYmYucmVhZFZhcmludCgpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TZXJ2ZXJHZW5zLndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai5taW5TZXJ2ZXJHZW4pDQogICAgICAgICAgICAgIHBiZi53cml0ZVZhcmludEZpZWxkKDEsIG9iai5taW5TZXJ2ZXJHZW4pOw0KICAgICAgICAgIGlmIChvYmouc2VydmVyR2VuKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCgyLCBvYmouc2VydmVyR2VuKTsNCiAgICAgIH07DQogICAgICAvLyBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2NhbGUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNjYWxlID0ge307DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2NhbGUucmVhZCA9IGZ1bmN0aW9uIChwYmYsIGVuZCkgew0KICAgICAgICAgIHJldHVybiBwYmYucmVhZEZpZWxkcyhGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2NhbGUuX3JlYWRGaWVsZCwgeyB4U2NhbGU6IDAsIHlTY2FsZTogMCwgbVNjYWxlOiAwLCB6U2NhbGU6IDAgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2NhbGUuX3JlYWRGaWVsZCA9IGZ1bmN0aW9uICh0YWcsIG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKHRhZyA9PT0gMSkNCiAgICAgICAgICAgICAgb2JqLnhTY2FsZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAyKQ0KICAgICAgICAgICAgICBvYmoueVNjYWxlID0gcGJmLnJlYWREb3VibGUoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDMpDQogICAgICAgICAgICAgIG9iai5tU2NhbGUgPSBwYmYucmVhZERvdWJsZSgpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkNCiAgICAgICAgICAgICAgb2JqLnpTY2FsZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICB9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNjYWxlLndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai54U2NhbGUpDQogICAgICAgICAgICAgIHBiZi53cml0ZURvdWJsZUZpZWxkKDEsIG9iai54U2NhbGUpOw0KICAgICAgICAgIGlmIChvYmoueVNjYWxlKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVEb3VibGVGaWVsZCgyLCBvYmoueVNjYWxlKTsNCiAgICAgICAgICBpZiAob2JqLm1TY2FsZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRG91YmxlRmllbGQoMywgb2JqLm1TY2FsZSk7DQogICAgICAgICAgaWYgKG9iai56U2NhbGUpDQogICAgICAgICAgICAgIHBiZi53cml0ZURvdWJsZUZpZWxkKDQsIG9iai56U2NhbGUpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5UcmFuc2xhdGUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZSA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZS5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5UcmFuc2xhdGUuX3JlYWRGaWVsZCwgeyB4VHJhbnNsYXRlOiAwLCB5VHJhbnNsYXRlOiAwLCBtVHJhbnNsYXRlOiAwLCB6VHJhbnNsYXRlOiAwIH0sIGVuZCk7DQogICAgICB9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZS5fcmVhZEZpZWxkID0gZnVuY3Rpb24gKHRhZywgb2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAodGFnID09PSAxKQ0KICAgICAgICAgICAgICBvYmoueFRyYW5zbGF0ZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAyKQ0KICAgICAgICAgICAgICBvYmoueVRyYW5zbGF0ZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmoubVRyYW5zbGF0ZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA0KQ0KICAgICAgICAgICAgICBvYmouelRyYW5zbGF0ZSA9IHBiZi5yZWFkRG91YmxlKCk7DQogICAgICB9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZS53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmoueFRyYW5zbGF0ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRG91YmxlRmllbGQoMSwgb2JqLnhUcmFuc2xhdGUpOw0KICAgICAgICAgIGlmIChvYmoueVRyYW5zbGF0ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRG91YmxlRmllbGQoMiwgb2JqLnlUcmFuc2xhdGUpOw0KICAgICAgICAgIGlmIChvYmoubVRyYW5zbGF0ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRG91YmxlRmllbGQoMywgb2JqLm1UcmFuc2xhdGUpOw0KICAgICAgICAgIGlmIChvYmouelRyYW5zbGF0ZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlRG91YmxlRmllbGQoNCwgb2JqLnpUcmFuc2xhdGUpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5UcmFuc2Zvcm0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zZm9ybSA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zZm9ybS5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5UcmFuc2Zvcm0uX3JlYWRGaWVsZCwgeyBxdWFudGl6ZU9yaWdpblBvc3Rpb246IDAsIHNjYWxlOiBudWxsLCB0cmFuc2xhdGU6IG51bGwgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuVHJhbnNmb3JtLl9yZWFkRmllbGQgPSBmdW5jdGlvbiAodGFnLCBvYmosIHBiZikgew0KICAgICAgICAgIGlmICh0YWcgPT09IDEpDQogICAgICAgICAgICAgIG9iai5xdWFudGl6ZU9yaWdpblBvc3Rpb24gPSBwYmYucmVhZFZhcmludCgpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gMikNCiAgICAgICAgICAgICAgb2JqLnNjYWxlID0gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNjYWxlLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmoudHJhbnNsYXRlID0gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZS5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5UcmFuc2Zvcm0ud3JpdGUgPSBmdW5jdGlvbiAob2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAob2JqLnF1YW50aXplT3JpZ2luUG9zdGlvbikNCiAgICAgICAgICAgICAgcGJmLndyaXRlVmFyaW50RmllbGQoMSwgb2JqLnF1YW50aXplT3JpZ2luUG9zdGlvbik7DQogICAgICAgICAgaWYgKG9iai5zY2FsZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgyLCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2NhbGUud3JpdGUsIG9iai5zY2FsZSk7DQogICAgICAgICAgaWYgKG9iai50cmFuc2xhdGUpDQogICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoMywgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zbGF0ZS53cml0ZSwgb2JqLnRyYW5zbGF0ZSk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkZlYXR1cmVSZXN1bHQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkZlYXR1cmVSZXN1bHQgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlUmVzdWx0LnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkZlYXR1cmVSZXN1bHQuX3JlYWRGaWVsZCwgeyBvYmplY3RJZEZpZWxkTmFtZTogIiIsIHVuaXF1ZUlkRmllbGQ6IG51bGwsIGdsb2JhbElkRmllbGROYW1lOiAiIiwgZ2VvaGFzaEZpZWxkTmFtZTogIiIsIGdlb21ldHJ5UHJvcGVydGllczogbnVsbCwgc2VydmVyR2VuczogbnVsbCwgZ2VvbWV0cnlUeXBlOiAwLCBzcGF0aWFsUmVmZXJlbmNlOiBudWxsLCBleGNlZWRlZFRyYW5zZmVyTGltaXQ6IGZhbHNlLCBoYXNaOiBmYWxzZSwgaGFzTTogZmFsc2UsIHRyYW5zZm9ybTogbnVsbCwgZmllbGRzOiBbXSwgdmFsdWVzOiBbXSwgZmVhdHVyZXM6IFtdIH0sIGVuZCk7DQogICAgICB9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkZlYXR1cmVSZXN1bHQuX3JlYWRGaWVsZCA9IGZ1bmN0aW9uICh0YWcsIG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKHRhZyA9PT0gMSkNCiAgICAgICAgICAgICAgb2JqLm9iamVjdElkRmllbGROYW1lID0gcGJmLnJlYWRTdHJpbmcoKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai51bmlxdWVJZEZpZWxkID0gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlVuaXF1ZUlkRmllbGQucmVhZChwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDMpDQogICAgICAgICAgICAgIG9iai5nbG9iYWxJZEZpZWxkTmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA0KQ0KICAgICAgICAgICAgICBvYmouZ2VvaGFzaEZpZWxkTmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA1KQ0KICAgICAgICAgICAgICBvYmouZ2VvbWV0cnlQcm9wZXJ0aWVzID0gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkdlb21ldHJ5UHJvcGVydGllcy5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gNikNCiAgICAgICAgICAgICAgb2JqLnNlcnZlckdlbnMgPSBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2VydmVyR2Vucy5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gNykNCiAgICAgICAgICAgICAgb2JqLmdlb21ldHJ5VHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA4KQ0KICAgICAgICAgICAgICBvYmouc3BhdGlhbFJlZmVyZW5jZSA9IEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TcGF0aWFsUmVmZXJlbmNlLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSA5KQ0KICAgICAgICAgICAgICBvYmouZXhjZWVkZWRUcmFuc2ZlckxpbWl0ID0gcGJmLnJlYWRCb29sZWFuKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAxMCkNCiAgICAgICAgICAgICAgb2JqLmhhc1ogPSBwYmYucmVhZEJvb2xlYW4oKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDExKQ0KICAgICAgICAgICAgICBvYmouaGFzTSA9IHBiZi5yZWFkQm9vbGVhbigpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gMTIpDQogICAgICAgICAgICAgIG9iai50cmFuc2Zvcm0gPSBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuVHJhbnNmb3JtLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAxMykNCiAgICAgICAgICAgICAgb2JqLmZpZWxkcy5wdXNoKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpKTsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDE0KQ0KICAgICAgICAgICAgICBvYmoudmFsdWVzLnB1c2goRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlZhbHVlLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcykpOw0KICAgICAgICAgIGVsc2UgaWYgKHRhZyA9PT0gMTUpDQogICAgICAgICAgICAgIG9iai5mZWF0dXJlcy5wdXNoKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcykpOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GZWF0dXJlUmVzdWx0LndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai5vYmplY3RJZEZpZWxkTmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLm9iamVjdElkRmllbGROYW1lKTsNCiAgICAgICAgICBpZiAob2JqLnVuaXF1ZUlkRmllbGQpDQogICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoMiwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlVuaXF1ZUlkRmllbGQud3JpdGUsIG9iai51bmlxdWVJZEZpZWxkKTsNCiAgICAgICAgICBpZiAob2JqLmdsb2JhbElkRmllbGROYW1lKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVTdHJpbmdGaWVsZCgzLCBvYmouZ2xvYmFsSWRGaWVsZE5hbWUpOw0KICAgICAgICAgIGlmIChvYmouZ2VvaGFzaEZpZWxkTmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoNCwgb2JqLmdlb2hhc2hGaWVsZE5hbWUpOw0KICAgICAgICAgIGlmIChvYmouZ2VvbWV0cnlQcm9wZXJ0aWVzKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVNZXNzYWdlKDUsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5HZW9tZXRyeVByb3BlcnRpZXMud3JpdGUsIG9iai5nZW9tZXRyeVByb3BlcnRpZXMpOw0KICAgICAgICAgIGlmIChvYmouc2VydmVyR2VucykNCiAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSg2LCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuU2VydmVyR2Vucy53cml0ZSwgb2JqLnNlcnZlckdlbnMpOw0KICAgICAgICAgIGlmIChvYmouZ2VvbWV0cnlUeXBlKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCg3LCBvYmouZ2VvbWV0cnlUeXBlKTsNCiAgICAgICAgICBpZiAob2JqLnNwYXRpYWxSZWZlcmVuY2UpDQogICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoOCwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNwYXRpYWxSZWZlcmVuY2Uud3JpdGUsIG9iai5zcGF0aWFsUmVmZXJlbmNlKTsNCiAgICAgICAgICBpZiAob2JqLmV4Y2VlZGVkVHJhbnNmZXJMaW1pdCkNCiAgICAgICAgICAgICAgcGJmLndyaXRlQm9vbGVhbkZpZWxkKDksIG9iai5leGNlZWRlZFRyYW5zZmVyTGltaXQpOw0KICAgICAgICAgIGlmIChvYmouaGFzWikNCiAgICAgICAgICAgICAgcGJmLndyaXRlQm9vbGVhbkZpZWxkKDEwLCBvYmouaGFzWik7DQogICAgICAgICAgaWYgKG9iai5oYXNNKQ0KICAgICAgICAgICAgICBwYmYud3JpdGVCb29sZWFuRmllbGQoMTEsIG9iai5oYXNNKTsNCiAgICAgICAgICBpZiAob2JqLnRyYW5zZm9ybSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgxMiwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlRyYW5zZm9ybS53cml0ZSwgb2JqLnRyYW5zZm9ybSk7DQogICAgICAgICAgaWYgKG9iai5maWVsZHMpDQogICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmZpZWxkcy5sZW5ndGg7IGkrKykNCiAgICAgICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoMTMsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5GaWVsZC53cml0ZSwgb2JqLmZpZWxkc1tpXSk7DQogICAgICAgICAgaWYgKG9iai52YWx1ZXMpDQogICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoudmFsdWVzLmxlbmd0aDsgaSsrKQ0KICAgICAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgxNCwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlZhbHVlLndyaXRlLCBvYmoudmFsdWVzW2ldKTsNCiAgICAgICAgICBpZiAob2JqLmZlYXR1cmVzKQ0KICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmZlYXR1cmVzLmxlbmd0aDsgaSsrKQ0KICAgICAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgxNSwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkZlYXR1cmUud3JpdGUsIG9iai5mZWF0dXJlc1tpXSk7DQogICAgICB9Ow0KICAgICAgLy8gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkNvdW50UmVzdWx0ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5Db3VudFJlc3VsdCA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkNvdW50UmVzdWx0LnJlYWQgPSBmdW5jdGlvbiAocGJmLCBlbmQpIHsNCiAgICAgICAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMoRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkNvdW50UmVzdWx0Ll9yZWFkRmllbGQsIHsgY291bnQ6IDAgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuQ291bnRSZXN1bHQuX3JlYWRGaWVsZCA9IGZ1bmN0aW9uICh0YWcsIG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKHRhZyA9PT0gMSkNCiAgICAgICAgICAgICAgb2JqLmNvdW50ID0gcGJmLnJlYWRWYXJpbnQoKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuQ291bnRSZXN1bHQud3JpdGUgPSBmdW5jdGlvbiAob2JqLCBwYmYpIHsNCiAgICAgICAgICBpZiAob2JqLmNvdW50KQ0KICAgICAgICAgICAgICBwYmYud3JpdGVWYXJpbnRGaWVsZCgxLCBvYmouY291bnQpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5PYmplY3RJZHNSZXN1bHQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLk9iamVjdElkc1Jlc3VsdCA9IHt9Ow0KICAgICAgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLk9iamVjdElkc1Jlc3VsdC5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5PYmplY3RJZHNSZXN1bHQuX3JlYWRGaWVsZCwgeyBvYmplY3RJZEZpZWxkTmFtZTogIiIsIHNlcnZlckdlbnM6IG51bGwsIG9iamVjdElkczogW10gfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuT2JqZWN0SWRzUmVzdWx0Ll9yZWFkRmllbGQgPSBmdW5jdGlvbiAodGFnLCBvYmosIHBiZikgew0KICAgICAgICAgIGlmICh0YWcgPT09IDEpDQogICAgICAgICAgICAgIG9iai5vYmplY3RJZEZpZWxkTmFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAyKQ0KICAgICAgICAgICAgICBvYmouc2VydmVyR2VucyA9IEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5TZXJ2ZXJHZW5zLnJlYWQocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBwYmYucmVhZFBhY2tlZFZhcmludChvYmoub2JqZWN0SWRzKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuT2JqZWN0SWRzUmVzdWx0LndyaXRlID0gZnVuY3Rpb24gKG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKG9iai5vYmplY3RJZEZpZWxkTmFtZSkNCiAgICAgICAgICAgICAgcGJmLndyaXRlU3RyaW5nRmllbGQoMSwgb2JqLm9iamVjdElkRmllbGROYW1lKTsNCiAgICAgICAgICBpZiAob2JqLnNlcnZlckdlbnMpDQogICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoMiwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLlNlcnZlckdlbnMud3JpdGUsIG9iai5zZXJ2ZXJHZW5zKTsNCiAgICAgICAgICBpZiAob2JqLm9iamVjdElkcykNCiAgICAgICAgICAgICAgcGJmLndyaXRlUGFja2VkVmFyaW50KDMsIG9iai5vYmplY3RJZHMpOw0KICAgICAgfTsNCiAgICAgIC8vIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5RdWVyeVJlc3VsdCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuUXVlcnlSZXN1bHQgPSB7fTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5RdWVyeVJlc3VsdC5yZWFkID0gZnVuY3Rpb24gKHBiZiwgZW5kKSB7DQogICAgICAgICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5RdWVyeVJlc3VsdC5fcmVhZEZpZWxkLCB7IGZlYXR1cmVSZXN1bHQ6IG51bGwsIFJlc3VsdHM6IG51bGwsIGNvdW50UmVzdWx0OiBudWxsLCBpZHNSZXN1bHQ6IG51bGwgfSwgZW5kKTsNCiAgICAgIH07DQogICAgICBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuUXVlcnlSZXN1bHQuX3JlYWRGaWVsZCA9IGZ1bmN0aW9uICh0YWcsIG9iaiwgcGJmKSB7DQogICAgICAgICAgaWYgKHRhZyA9PT0gMSkNCiAgICAgICAgICAgICAgb2JqLmZlYXR1cmVSZXN1bHQgPSBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuRmVhdHVyZVJlc3VsdC5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpLCBvYmouUmVzdWx0cyA9ICJmZWF0dXJlUmVzdWx0IjsNCiAgICAgICAgICBlbHNlIGlmICh0YWcgPT09IDIpDQogICAgICAgICAgICAgIG9iai5jb3VudFJlc3VsdCA9IEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5Db3VudFJlc3VsdC5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpLCBvYmouUmVzdWx0cyA9ICJjb3VudFJlc3VsdCI7DQogICAgICAgICAgZWxzZSBpZiAodGFnID09PSAzKQ0KICAgICAgICAgICAgICBvYmouaWRzUmVzdWx0ID0gRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLk9iamVjdElkc1Jlc3VsdC5yZWFkKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpLCBvYmouUmVzdWx0cyA9ICJpZHNSZXN1bHQiOw0KICAgICAgfTsNCiAgICAgIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5RdWVyeVJlc3VsdC53cml0ZSA9IGZ1bmN0aW9uIChvYmosIHBiZikgew0KICAgICAgICAgIGlmIChvYmouZmVhdHVyZVJlc3VsdCkNCiAgICAgICAgICAgICAgcGJmLndyaXRlTWVzc2FnZSgxLCBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXIuRmVhdHVyZVJlc3VsdC53cml0ZSwgb2JqLmZlYXR1cmVSZXN1bHQpOw0KICAgICAgICAgIGlmIChvYmouY291bnRSZXN1bHQpDQogICAgICAgICAgICAgIHBiZi53cml0ZU1lc3NhZ2UoMiwgRmVhdHVyZUNvbGxlY3Rpb25QQnVmZmVyLkNvdW50UmVzdWx0LndyaXRlLCBvYmouY291bnRSZXN1bHQpOw0KICAgICAgICAgIGlmIChvYmouaWRzUmVzdWx0KQ0KICAgICAgICAgICAgICBwYmYud3JpdGVNZXNzYWdlKDMsIEZlYXR1cmVDb2xsZWN0aW9uUEJ1ZmZlci5PYmplY3RJZHNSZXN1bHQud3JpdGUsIG9iai5pZHNSZXN1bHQpOw0KICAgICAgfTsNCiAgICAgIHJldHVybiBGZWF0dXJlQ29sbGVjdGlvblBCdWZmZXI7DQogIH0NCiAgOwoKICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTsKCiAgZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHsKICAJcmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDsKICB9CgogIGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IChuKSB7CiAgCXJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpID8gblsnZGVmYXVsdCddIDogbjsKICB9CgogIGZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCAobikgewogIAlyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuOwogIH0KCiAgZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHsKICAgIGlmIChuLl9fZXNNb2R1bGUpIHJldHVybiBuOwogICAgdmFyIGYgPSBuLmRlZmF1bHQ7CiAgCWlmICh0eXBlb2YgZiA9PSAiZnVuY3Rpb24iKSB7CiAgCQl2YXIgYSA9IGZ1bmN0aW9uIGEgKCkgewogIAkJCWlmICh0aGlzIGluc3RhbmNlb2YgYSkgewogIAkJCQl2YXIgYXJncyA9IFtudWxsXTsKICAJCQkJYXJncy5wdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7CiAgCQkJCXZhciBDdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShmLCBhcmdzKTsKICAJCQkJcmV0dXJuIG5ldyBDdG9yKCk7CiAgCQkJfQogIAkJCXJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgCQl9OwogIAkJYS5wcm90b3R5cGUgPSBmLnByb3RvdHlwZTsKICAgIH0gZWxzZSBhID0ge307CiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTsKICAJT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbiAoaykgewogIAkJdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspOwogIAkJT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHsKICAJCQllbnVtZXJhYmxlOiB0cnVlLAogIAkJCWdldDogZnVuY3Rpb24gKCkgewogIAkJCQlyZXR1cm4gbltrXTsKICAJCQl9CiAgCQl9KTsKICAJfSk7CiAgCXJldHVybiBhOwogIH0KCiAgdmFyIGllZWU3NTQkMSA9IHt9OwoKICAvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqLwoKICB2YXIgcmVhZCA9IGllZWU3NTQkMS5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgIHZhciBlLCBtOwogICAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMTsKICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgdmFyIG5CaXRzID0gLTc7CiAgICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwOwogICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxOwogICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07CgogICAgaSArPSBkOwoKICAgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpOwogICAgcyA+Pj0gKC1uQml0cyk7CiAgICBuQml0cyArPSBlTGVuOwogICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICAgIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpOwogICAgZSA+Pj0gKC1uQml0cyk7CiAgICBuQml0cyArPSBtTGVuOwogICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICAgIGlmIChlID09PSAwKSB7CiAgICAgIGUgPSAxIC0gZUJpYXM7CiAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpCiAgICB9IGVsc2UgewogICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pOwogICAgICBlID0gZSAtIGVCaWFzOwogICAgfQogICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbikKICB9OwoKICB2YXIgd3JpdGUgPSBpZWVlNzU0JDEud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICAgIHZhciBlLCBtLCBjOwogICAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMTsKICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxOwogICAgdmFyIGVCaWFzID0gZU1heCA+PiAxOwogICAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTsKICAgIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSk7CiAgICB2YXIgZCA9IGlzTEUgPyAxIDogLTE7CiAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDsKCiAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTsKCiAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7CiAgICAgIGUgPSBlTWF4OwogICAgfSBlbHNlIHsKICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpOwogICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgICAgZS0tOwogICAgICAgIGMgKj0gMjsKICAgICAgfQogICAgICBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgICB2YWx1ZSArPSBydCAvIGM7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpOwogICAgICB9CiAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikgewogICAgICAgIGUrKzsKICAgICAgICBjIC89IDI7CiAgICAgIH0KCiAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICAgIG0gPSAwOwogICAgICAgIGUgPSBlTWF4OwogICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgZSA9IGUgKyBlQmlhczsKICAgICAgfSBlbHNlIHsKICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7CiAgICAgICAgZSA9IDA7CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fQoKICAgIGUgPSAoZSA8PCBtTGVuKSB8IG07CiAgICBlTGVuICs9IG1MZW47CiAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9CgogICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4OwogIH07CgogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIHBiZiA9IFBiZjsKCiAgdmFyIGllZWU3NTQgPSBpZWVlNzU0JDE7CgogIGZ1bmN0aW9uIFBiZihidWYpIHsKICAgICAgdGhpcy5idWYgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGJ1ZikgPyBidWYgOiBuZXcgVWludDhBcnJheShidWYgfHwgMCk7CiAgICAgIHRoaXMucG9zID0gMDsKICAgICAgdGhpcy50eXBlID0gMDsKICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ1Zi5sZW5ndGg7CiAgfQoKICBQYmYuVmFyaW50ICA9IDA7IC8vIHZhcmludDogaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW0KICBQYmYuRml4ZWQ2NCA9IDE7IC8vIDY0LWJpdDogZG91YmxlLCBmaXhlZDY0LCBzZml4ZWQ2NAogIFBiZi5CeXRlcyAgID0gMjsgLy8gbGVuZ3RoLWRlbGltaXRlZDogc3RyaW5nLCBieXRlcywgZW1iZWRkZWQgbWVzc2FnZXMsIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMKICBQYmYuRml4ZWQzMiA9IDU7IC8vIDMyLWJpdDogZmxvYXQsIGZpeGVkMzIsIHNmaXhlZDMyCgogIHZhciBTSElGVF9MRUZUXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpLAogICAgICBTSElGVF9SSUdIVF8zMiA9IDEgLyBTSElGVF9MRUZUXzMyOwoKICAvLyBUaHJlc2hvbGQgY2hvc2VuIGJhc2VkIG9uIGJvdGggYmVuY2htYXJraW5nIGFuZCBrbm93bGVkZ2UgYWJvdXQgYnJvd3NlciBzdHJpbmcKICAvLyBkYXRhIHN0cnVjdHVyZXMgKHdoaWNoIGN1cnJlbnRseSBzd2l0Y2ggc3RydWN0dXJlIHR5cGVzIGF0IDEyIGJ5dGVzIG9yIG1vcmUpCiAgdmFyIFRFWFRfREVDT0RFUl9NSU5fTEVOR1RIID0gMTI7CiAgdmFyIHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGY4Jyk7CgogIFBiZi5wcm90b3R5cGUgPSB7CgogICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMuYnVmID0gbnVsbDsKICAgICAgfSwKCiAgICAgIC8vID09PSBSRUFESU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CgogICAgICByZWFkRmllbGRzOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCwgZW5kKSB7CiAgICAgICAgICBlbmQgPSBlbmQgfHwgdGhpcy5sZW5ndGg7CgogICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSB7CiAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLAogICAgICAgICAgICAgICAgICB0YWcgPSB2YWwgPj4gMywKICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSB0aGlzLnBvczsKCiAgICAgICAgICAgICAgdGhpcy50eXBlID0gdmFsICYgMHg3OwogICAgICAgICAgICAgIHJlYWRGaWVsZCh0YWcsIHJlc3VsdCwgdGhpcyk7CgogICAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnRQb3MpIHRoaXMuc2tpcCh2YWwpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfSwKCiAgICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkgewogICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZpZWxkcyhyZWFkRmllbGQsIHJlc3VsdCwgdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcyk7CiAgICAgIH0sCgogICAgICByZWFkRml4ZWQzMjogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgdmFsID0gcmVhZFVJbnQzMih0aGlzLmJ1ZiwgdGhpcy5wb3MpOwogICAgICAgICAgdGhpcy5wb3MgKz0gNDsKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgIH0sCgogICAgICByZWFkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHZhbCA9IHJlYWRJbnQzMih0aGlzLmJ1ZiwgdGhpcy5wb3MpOwogICAgICAgICAgdGhpcy5wb3MgKz0gNDsKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgIH0sCgogICAgICAvLyA2NC1iaXQgaW50IGhhbmRsaW5nIGlzIGJhc2VkIG9uIGdpdGh1Yi5jb20vZHB3L25vZGUtYnVmZmVyLW1vcmUtaW50cyAoTUlULWxpY2Vuc2VkKQoKICAgICAgcmVhZEZpeGVkNjQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHZhbCA9IHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zKSArIHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zICsgNCkgKiBTSElGVF9MRUZUXzMyOwogICAgICAgICAgdGhpcy5wb3MgKz0gODsKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgIH0sCgogICAgICByZWFkU0ZpeGVkNjQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIHZhbCA9IHJlYWRVSW50MzIodGhpcy5idWYsIHRoaXMucG9zKSArIHJlYWRJbnQzMih0aGlzLmJ1ZiwgdGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7CiAgICAgICAgICB0aGlzLnBvcyArPSA4OwogICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfSwKCiAgICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgdmFsID0gaWVlZTc1NC5yZWFkKHRoaXMuYnVmLCB0aGlzLnBvcywgdHJ1ZSwgMjMsIDQpOwogICAgICAgICAgdGhpcy5wb3MgKz0gNDsKICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgIH0sCgogICAgICByZWFkRG91YmxlOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciB2YWwgPSBpZWVlNzU0LnJlYWQodGhpcy5idWYsIHRoaXMucG9zLCB0cnVlLCA1MiwgOCk7CiAgICAgICAgICB0aGlzLnBvcyArPSA4OwogICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfSwKCiAgICAgIHJlYWRWYXJpbnQ6IGZ1bmN0aW9uKGlzU2lnbmVkKSB7CiAgICAgICAgICB2YXIgYnVmID0gdGhpcy5idWYsCiAgICAgICAgICAgICAgdmFsLCBiOwoKICAgICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCAgPSAgYiAmIDB4N2Y7ICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7CiAgICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCA3OyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsOwogICAgICAgICAgYiA9IGJ1Zlt0aGlzLnBvcysrXTsgdmFsIHw9IChiICYgMHg3ZikgPDwgMTQ7IGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDsKICAgICAgICAgIGIgPSBidWZbdGhpcy5wb3MrK107IHZhbCB8PSAoYiAmIDB4N2YpIDw8IDIxOyBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7CiAgICAgICAgICBiID0gYnVmW3RoaXMucG9zXTsgICB2YWwgfD0gKGIgJiAweDBmKSA8PCAyODsKCiAgICAgICAgICByZXR1cm4gcmVhZFZhcmludFJlbWFpbmRlcih2YWwsIGlzU2lnbmVkLCB0aGlzKTsKICAgICAgfSwKCiAgICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7IC8vIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdjIuMC4xCiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkVmFyaW50KHRydWUpOwogICAgICB9LAoKICAgICAgcmVhZFNWYXJpbnQ6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdmFyIG51bSA9IHRoaXMucmVhZFZhcmludCgpOwogICAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZwogICAgICB9LAoKICAgICAgcmVhZEJvb2xlYW46IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkVmFyaW50KCkpOwogICAgICB9LAoKICAgICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7CiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvczsKICAgICAgICAgIHZhciBwb3MgPSB0aGlzLnBvczsKICAgICAgICAgIHRoaXMucG9zID0gZW5kOwoKICAgICAgICAgIGlmIChlbmQgLSBwb3MgPj0gVEVYVF9ERUNPREVSX01JTl9MRU5HVEggJiYgdXRmOFRleHREZWNvZGVyKSB7CiAgICAgICAgICAgICAgLy8gbG9uZ2VyIHN0cmluZ3MgYXJlIGZhc3Qgd2l0aCB0aGUgYnVpbHQtaW4gYnJvd3NlciBUZXh0RGVjb2RlciBBUEkKICAgICAgICAgICAgICByZXR1cm4gcmVhZFV0ZjhUZXh0RGVjb2Rlcih0aGlzLmJ1ZiwgcG9zLCBlbmQpOwogICAgICAgICAgfQogICAgICAgICAgLy8gc2hvcnQgc3RyaW5ncyBhcmUgZmFzdCB3aXRoIG91ciBjdXN0b20gaW1wbGVtZW50YXRpb24KICAgICAgICAgIHJldHVybiByZWFkVXRmOCh0aGlzLmJ1ZiwgcG9zLCBlbmQpOwogICAgICB9LAoKICAgICAgcmVhZEJ5dGVzOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLAogICAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuYnVmLnN1YmFycmF5KHRoaXMucG9zLCBlbmQpOwogICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7CiAgICAgICAgICByZXR1cm4gYnVmZmVyOwogICAgICB9LAoKICAgICAgLy8gdmVyYm9zZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczsgZG9lc24ndCBhZmZlY3QgZ3ppcHBlZCBzaXplCgogICAgICByZWFkUGFja2VkVmFyaW50OiBmdW5jdGlvbihhcnIsIGlzU2lnbmVkKSB7CiAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSBQYmYuQnl0ZXMpIHJldHVybiBhcnIucHVzaCh0aGlzLnJlYWRWYXJpbnQoaXNTaWduZWQpKTsKICAgICAgICAgIHZhciBlbmQgPSByZWFkUGFja2VkRW5kKHRoaXMpOwogICAgICAgICAgYXJyID0gYXJyIHx8IFtdOwogICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRWYXJpbnQoaXNTaWduZWQpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRTVmFyaW50OiBmdW5jdGlvbihhcnIpIHsKICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFBiZi5CeXRlcykgcmV0dXJuIGFyci5wdXNoKHRoaXMucmVhZFNWYXJpbnQoKSk7CiAgICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTsKICAgICAgICAgIGFyciA9IGFyciB8fCBbXTsKICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbihhcnIpIHsKICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFBiZi5CeXRlcykgcmV0dXJuIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7CiAgICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTsKICAgICAgICAgIGFyciA9IGFyciB8fCBbXTsKICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkQm9vbGVhbigpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRGbG9hdDogZnVuY3Rpb24oYXJyKSB7CiAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSBQYmYuQnl0ZXMpIHJldHVybiBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTsKICAgICAgICAgIHZhciBlbmQgPSByZWFkUGFja2VkRW5kKHRoaXMpOwogICAgICAgICAgYXJyID0gYXJyIHx8IFtdOwogICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGbG9hdCgpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWREb3VibGU6IGZ1bmN0aW9uKGFycikgewogICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gUGJmLkJ5dGVzKSByZXR1cm4gYXJyLnB1c2godGhpcy5yZWFkRG91YmxlKCkpOwogICAgICAgICAgdmFyIGVuZCA9IHJlYWRQYWNrZWRFbmQodGhpcyk7CiAgICAgICAgICBhcnIgPSBhcnIgfHwgW107CiAgICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbihhcnIpIHsKICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFBiZi5CeXRlcykgcmV0dXJuIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7CiAgICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTsKICAgICAgICAgIGFyciA9IGFyciB8fCBbXTsKICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQzMigpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRTRml4ZWQzMjogZnVuY3Rpb24oYXJyKSB7CiAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSBQYmYuQnl0ZXMpIHJldHVybiBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTsKICAgICAgICAgIHZhciBlbmQgPSByZWFkUGFja2VkRW5kKHRoaXMpOwogICAgICAgICAgYXJyID0gYXJyIHx8IFtdOwogICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQzMigpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRGaXhlZDY0OiBmdW5jdGlvbihhcnIpIHsKICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IFBiZi5CeXRlcykgcmV0dXJuIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkNjQoKSk7CiAgICAgICAgICB2YXIgZW5kID0gcmVhZFBhY2tlZEVuZCh0aGlzKTsKICAgICAgICAgIGFyciA9IGFyciB8fCBbXTsKICAgICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRml4ZWQ2NCgpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCiAgICAgIHJlYWRQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24oYXJyKSB7CiAgICAgICAgICBpZiAodGhpcy50eXBlICE9PSBQYmYuQnl0ZXMpIHJldHVybiBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTsKICAgICAgICAgIHZhciBlbmQgPSByZWFkUGFja2VkRW5kKHRoaXMpOwogICAgICAgICAgYXJyID0gYXJyIHx8IFtdOwogICAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRTRml4ZWQ2NCgpKTsKICAgICAgICAgIHJldHVybiBhcnI7CiAgICAgIH0sCgogICAgICBza2lwOiBmdW5jdGlvbih2YWwpIHsKICAgICAgICAgIHZhciB0eXBlID0gdmFsICYgMHg3OwogICAgICAgICAgaWYgKHR5cGUgPT09IFBiZi5WYXJpbnQpIHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA+IDB4N2YpIHt9CiAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvczsKICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDMyKSB0aGlzLnBvcyArPSA0OwogICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkNjQpIHRoaXMucG9zICs9IDg7CiAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7CiAgICAgIH0sCgogICAgICAvLyA9PT0gV1JJVElORyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoKICAgICAgd3JpdGVUYWc6IGZ1bmN0aW9uKHRhZywgdHlwZSkgewogICAgICAgICAgdGhpcy53cml0ZVZhcmludCgodGFnIDw8IDMpIHwgdHlwZSk7CiAgICAgIH0sCgogICAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHsKICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAxNjsKCiAgICAgICAgICB3aGlsZSAobGVuZ3RoIDwgdGhpcy5wb3MgKyBtaW4pIGxlbmd0aCAqPSAyOwoKICAgICAgICAgIGlmIChsZW5ndGggIT09IHRoaXMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICAgICAgICAgICAgYnVmLnNldCh0aGlzLmJ1Zik7CiAgICAgICAgICAgICAgdGhpcy5idWYgPSBidWY7CiAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7CiAgICAgICAgICB9CiAgICAgIH0sCgogICAgICBmaW5pc2g6IGZ1bmN0aW9uKCkgewogICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLnBvczsKICAgICAgICAgIHRoaXMucG9zID0gMDsKICAgICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7CiAgICAgIH0sCgogICAgICB3cml0ZUZpeGVkMzI6IGZ1bmN0aW9uKHZhbCkgewogICAgICAgICAgdGhpcy5yZWFsbG9jKDQpOwogICAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsLCB0aGlzLnBvcyk7CiAgICAgICAgICB0aGlzLnBvcyArPSA0OwogICAgICB9LAoKICAgICAgd3JpdGVTRml4ZWQzMjogZnVuY3Rpb24odmFsKSB7CiAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7CiAgICAgICAgICB3cml0ZUludDMyKHRoaXMuYnVmLCB2YWwsIHRoaXMucG9zKTsKICAgICAgICAgIHRoaXMucG9zICs9IDQ7CiAgICAgIH0sCgogICAgICB3cml0ZUZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkgewogICAgICAgICAgdGhpcy5yZWFsbG9jKDgpOwogICAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsICYgLTEsIHRoaXMucG9zKTsKICAgICAgICAgIHdyaXRlSW50MzIodGhpcy5idWYsIE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpOwogICAgICAgICAgdGhpcy5wb3MgKz0gODsKICAgICAgfSwKCiAgICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkgewogICAgICAgICAgdGhpcy5yZWFsbG9jKDgpOwogICAgICAgICAgd3JpdGVJbnQzMih0aGlzLmJ1ZiwgdmFsICYgLTEsIHRoaXMucG9zKTsKICAgICAgICAgIHdyaXRlSW50MzIodGhpcy5idWYsIE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCB0aGlzLnBvcyArIDQpOwogICAgICAgICAgdGhpcy5wb3MgKz0gODsKICAgICAgfSwKCiAgICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHsKICAgICAgICAgIHZhbCA9ICt2YWwgfHwgMDsKCiAgICAgICAgICBpZiAodmFsID4gMHhmZmZmZmZmIHx8IHZhbCA8IDApIHsKICAgICAgICAgICAgICB3cml0ZUJpZ1ZhcmludCh2YWwsIHRoaXMpOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7CgogICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAgICAgICAgICAgdmFsICYgMHg3ZiAgfCAodmFsID4gMHg3ZiA/IDB4ODAgOiAwKTsgaWYgKHZhbCA8PSAweDdmKSByZXR1cm47CiAgICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+Pj0gNykgJiAweDdmKSB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjsKICAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gKCh2YWwgPj4+PSA3KSAmIDB4N2YpIHwgKHZhbCA+IDB4N2YgPyAweDgwIDogMCk7IGlmICh2YWwgPD0gMHg3ZikgcmV0dXJuOwogICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAgICh2YWwgPj4+IDcpICYgMHg3ZjsKICAgICAgfSwKCiAgICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24odmFsKSB7CiAgICAgICAgICB0aGlzLndyaXRlVmFyaW50KHZhbCA8IDAgPyAtdmFsICogMiAtIDEgOiB2YWwgKiAyKTsKICAgICAgfSwKCiAgICAgIHdyaXRlQm9vbGVhbjogZnVuY3Rpb24odmFsKSB7CiAgICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odmFsKSk7CiAgICAgIH0sCgogICAgICB3cml0ZVN0cmluZzogZnVuY3Rpb24oc3RyKSB7CiAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTsKICAgICAgICAgIHRoaXMucmVhbGxvYyhzdHIubGVuZ3RoICogNCk7CgogICAgICAgICAgdGhpcy5wb3MrKzsgLy8gcmVzZXJ2ZSAxIGJ5dGUgZm9yIHNob3J0IHN0cmluZyBsZW5ndGgKCiAgICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnBvczsKICAgICAgICAgIC8vIHdyaXRlIHRoZSBzdHJpbmcgZGlyZWN0bHkgdG8gdGhlIGJ1ZmZlciBhbmQgc2VlIGhvdyBtdWNoIHdhcyB3cml0dGVuCiAgICAgICAgICB0aGlzLnBvcyA9IHdyaXRlVXRmOCh0aGlzLmJ1Ziwgc3RyLCB0aGlzLnBvcyk7CiAgICAgICAgICB2YXIgbGVuID0gdGhpcy5wb3MgLSBzdGFydFBvczsKCiAgICAgICAgICBpZiAobGVuID49IDB4ODApIG1ha2VSb29tRm9yRXh0cmFMZW5ndGgoc3RhcnRQb3MsIGxlbiwgdGhpcyk7CgogICAgICAgICAgLy8gZmluYWxseSwgd3JpdGUgdGhlIG1lc3NhZ2UgbGVuZ3RoIGluIHRoZSByZXNlcnZlZCBwbGFjZSBhbmQgcmVzdG9yZSB0aGUgcG9zaXRpb24KICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRQb3MgLSAxOwogICAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pOwogICAgICAgICAgdGhpcy5wb3MgKz0gbGVuOwogICAgICB9LAoKICAgICAgd3JpdGVGbG9hdDogZnVuY3Rpb24odmFsKSB7CiAgICAgICAgICB0aGlzLnJlYWxsb2MoNCk7CiAgICAgICAgICBpZWVlNzU0LndyaXRlKHRoaXMuYnVmLCB2YWwsIHRoaXMucG9zLCB0cnVlLCAyMywgNCk7CiAgICAgICAgICB0aGlzLnBvcyArPSA0OwogICAgICB9LAoKICAgICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKHZhbCkgewogICAgICAgICAgdGhpcy5yZWFsbG9jKDgpOwogICAgICAgICAgaWVlZTc1NC53cml0ZSh0aGlzLmJ1ZiwgdmFsLCB0aGlzLnBvcywgdHJ1ZSwgNTIsIDgpOwogICAgICAgICAgdGhpcy5wb3MgKz0gODsKICAgICAgfSwKCiAgICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uKGJ1ZmZlcikgewogICAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7CiAgICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7CiAgICAgICAgICB0aGlzLnJlYWxsb2MobGVuKTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXMuYnVmW3RoaXMucG9zKytdID0gYnVmZmVyW2ldOwogICAgICB9LAoKICAgICAgd3JpdGVSYXdNZXNzYWdlOiBmdW5jdGlvbihmbiwgb2JqKSB7CiAgICAgICAgICB0aGlzLnBvcysrOyAvLyByZXNlcnZlIDEgYnl0ZSBmb3Igc2hvcnQgbWVzc2FnZSBsZW5ndGgKCiAgICAgICAgICAvLyB3cml0ZSB0aGUgbWVzc2FnZSBkaXJlY3RseSB0byB0aGUgYnVmZmVyIGFuZCBzZWUgaG93IG11Y2ggd2FzIHdyaXR0ZW4KICAgICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zOwogICAgICAgICAgZm4ob2JqLCB0aGlzKTsKICAgICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zOwoKICAgICAgICAgIGlmIChsZW4gPj0gMHg4MCkgbWFrZVJvb21Gb3JFeHRyYUxlbmd0aChzdGFydFBvcywgbGVuLCB0aGlzKTsKCiAgICAgICAgICAvLyBmaW5hbGx5LCB3cml0ZSB0aGUgbWVzc2FnZSBsZW5ndGggaW4gdGhlIHJlc2VydmVkIHBsYWNlIGFuZCByZXN0b3JlIHRoZSBwb3NpdGlvbgogICAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7CiAgICAgICAgICB0aGlzLndyaXRlVmFyaW50KGxlbik7CiAgICAgICAgICB0aGlzLnBvcyArPSBsZW47CiAgICAgIH0sCgogICAgICB3cml0ZU1lc3NhZ2U6IGZ1bmN0aW9uKHRhZywgZm4sIG9iaikgewogICAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7CiAgICAgICAgICB0aGlzLndyaXRlUmF3TWVzc2FnZShmbiwgb2JqKTsKICAgICAgfSwKCiAgICAgIHdyaXRlUGFja2VkVmFyaW50OiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkVmFyaW50LCBhcnIpOyAgIH0sCiAgICAgIHdyaXRlUGFja2VkU1ZhcmludDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU1ZhcmludCwgYXJyKTsgIH0sCiAgICAgIHdyaXRlUGFja2VkQm9vbGVhbjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkQm9vbGVhbiwgYXJyKTsgIH0sCiAgICAgIHdyaXRlUGFja2VkRmxvYXQ6ICAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRmxvYXQsIGFycik7ICAgIH0sCiAgICAgIHdyaXRlUGFja2VkRG91YmxlOiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRG91YmxlLCBhcnIpOyAgIH0sCiAgICAgIHdyaXRlUGFja2VkRml4ZWQzMjogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQzMiwgYXJyKTsgIH0sCiAgICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkMzIsIGFycik7IH0sCiAgICAgIHdyaXRlUGFja2VkRml4ZWQ2NDogIGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQ2NCwgYXJyKTsgIH0sCiAgICAgIHdyaXRlUGFja2VkU0ZpeGVkNjQ6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IGlmIChhcnIubGVuZ3RoKSB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU0ZpeGVkNjQsIGFycik7IH0sCgogICAgICB3cml0ZUJ5dGVzRmllbGQ6IGZ1bmN0aW9uKHRhZywgYnVmZmVyKSB7CiAgICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTsKICAgICAgICAgIHRoaXMud3JpdGVCeXRlcyhidWZmZXIpOwogICAgICB9LAogICAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHsKICAgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7CiAgICAgICAgICB0aGlzLndyaXRlRml4ZWQzMih2YWwpOwogICAgICB9LAogICAgICB3cml0ZVNGaXhlZDMyRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7CiAgICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpOwogICAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7CiAgICAgIH0sCiAgICAgIHdyaXRlRml4ZWQ2NEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkgewogICAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTsKICAgICAgICAgIHRoaXMud3JpdGVGaXhlZDY0KHZhbCk7CiAgICAgIH0sCiAgICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHsKICAgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7CiAgICAgICAgICB0aGlzLndyaXRlU0ZpeGVkNjQodmFsKTsKICAgICAgfSwKICAgICAgd3JpdGVWYXJpbnRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHsKICAgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuVmFyaW50KTsKICAgICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTsKICAgICAgfSwKICAgICAgd3JpdGVTVmFyaW50RmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7CiAgICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7CiAgICAgICAgICB0aGlzLndyaXRlU1ZhcmludCh2YWwpOwogICAgICB9LAogICAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikgewogICAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5CeXRlcyk7CiAgICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHN0cik7CiAgICAgIH0sCiAgICAgIHdyaXRlRmxvYXRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHsKICAgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQzMik7CiAgICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTsKICAgICAgfSwKICAgICAgd3JpdGVEb3VibGVGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHsKICAgICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7CiAgICAgICAgICB0aGlzLndyaXRlRG91YmxlKHZhbCk7CiAgICAgIH0sCiAgICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkgewogICAgICAgICAgdGhpcy53cml0ZVZhcmludEZpZWxkKHRhZywgQm9vbGVhbih2YWwpKTsKICAgICAgfQogIH07CgogIGZ1bmN0aW9uIHJlYWRWYXJpbnRSZW1haW5kZXIobCwgcywgcCkgewogICAgICB2YXIgYnVmID0gcC5idWYsCiAgICAgICAgICBoLCBiOwoKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCAgPSAoYiAmIDB4NzApID4+IDQ7ICBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4N2YpIDw8IDM7ICBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4N2YpIDw8IDEwOyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4N2YpIDw8IDE3OyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4N2YpIDw8IDI0OyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKICAgICAgYiA9IGJ1ZltwLnBvcysrXTsgaCB8PSAoYiAmIDB4MDEpIDw8IDMxOyBpZiAoYiA8IDB4ODApIHJldHVybiB0b051bShsLCBoLCBzKTsKCiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFyaW50IG5vdCBtb3JlIHRoYW4gMTAgYnl0ZXMnKTsKICB9CgogIGZ1bmN0aW9uIHJlYWRQYWNrZWRFbmQocGJmKSB7CiAgICAgIHJldHVybiBwYmYudHlwZSA9PT0gUGJmLkJ5dGVzID8KICAgICAgICAgIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zIDogcGJmLnBvcyArIDE7CiAgfQoKICBmdW5jdGlvbiB0b051bShsb3csIGhpZ2gsIGlzU2lnbmVkKSB7CiAgICAgIGlmIChpc1NpZ25lZCkgewogICAgICAgICAgcmV0dXJuIGhpZ2ggKiAweDEwMDAwMDAwMCArIChsb3cgPj4+IDApOwogICAgICB9CgogICAgICByZXR1cm4gKChoaWdoID4+PiAwKSAqIDB4MTAwMDAwMDAwKSArIChsb3cgPj4+IDApOwogIH0KCiAgZnVuY3Rpb24gd3JpdGVCaWdWYXJpbnQodmFsLCBwYmYpIHsKICAgICAgdmFyIGxvdywgaGlnaDsKCiAgICAgIGlmICh2YWwgPj0gMCkgewogICAgICAgICAgbG93ICA9ICh2YWwgJSAweDEwMDAwMDAwMCkgfCAwOwogICAgICAgICAgaGlnaCA9ICh2YWwgLyAweDEwMDAwMDAwMCkgfCAwOwogICAgICB9IGVsc2UgewogICAgICAgICAgbG93ICA9IH4oLXZhbCAlIDB4MTAwMDAwMDAwKTsKICAgICAgICAgIGhpZ2ggPSB+KC12YWwgLyAweDEwMDAwMDAwMCk7CgogICAgICAgICAgaWYgKGxvdyBeIDB4ZmZmZmZmZmYpIHsKICAgICAgICAgICAgICBsb3cgPSAobG93ICsgMSkgfCAwOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBsb3cgPSAwOwogICAgICAgICAgICAgIGhpZ2ggPSAoaGlnaCArIDEpIHwgMDsKICAgICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHZhbCA+PSAweDEwMDAwMDAwMDAwMDAwMDAwIHx8IHZhbCA8IC0weDEwMDAwMDAwMDAwMDAwMDAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhcmludCBkb2VzblwndCBmaXQgaW50byAxMCBieXRlcycpOwogICAgICB9CgogICAgICBwYmYucmVhbGxvYygxMCk7CgogICAgICB3cml0ZUJpZ1ZhcmludExvdyhsb3csIGhpZ2gsIHBiZik7CiAgICAgIHdyaXRlQmlnVmFyaW50SGlnaChoaWdoLCBwYmYpOwogIH0KCiAgZnVuY3Rpb24gd3JpdGVCaWdWYXJpbnRMb3cobG93LCBoaWdoLCBwYmYpIHsKICAgICAgcGJmLmJ1ZltwYmYucG9zKytdID0gbG93ICYgMHg3ZiB8IDB4ODA7IGxvdyA+Pj49IDc7CiAgICAgIHBiZi5idWZbcGJmLnBvcysrXSA9IGxvdyAmIDB4N2YgfCAweDgwOyBsb3cgPj4+PSA3OwogICAgICBwYmYuYnVmW3BiZi5wb3MrK10gPSBsb3cgJiAweDdmIHwgMHg4MDsgbG93ID4+Pj0gNzsKICAgICAgcGJmLmJ1ZltwYmYucG9zKytdID0gbG93ICYgMHg3ZiB8IDB4ODA7IGxvdyA+Pj49IDc7CiAgICAgIHBiZi5idWZbcGJmLnBvc10gICA9IGxvdyAmIDB4N2Y7CiAgfQoKICBmdW5jdGlvbiB3cml0ZUJpZ1ZhcmludEhpZ2goaGlnaCwgcGJmKSB7CiAgICAgIHZhciBsc2IgPSAoaGlnaCAmIDB4MDcpIDw8IDQ7CgogICAgICBwYmYuYnVmW3BiZi5wb3MrK10gfD0gbHNiICAgICAgICAgfCAoKGhpZ2ggPj4+PSAzKSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47CiAgICAgIHBiZi5idWZbcGJmLnBvcysrXSAgPSBoaWdoICYgMHg3ZiB8ICgoaGlnaCA+Pj49IDcpID8gMHg4MCA6IDApOyBpZiAoIWhpZ2gpIHJldHVybjsKICAgICAgcGJmLmJ1ZltwYmYucG9zKytdICA9IGhpZ2ggJiAweDdmIHwgKChoaWdoID4+Pj0gNykgPyAweDgwIDogMCk7IGlmICghaGlnaCkgcmV0dXJuOwogICAgICBwYmYuYnVmW3BiZi5wb3MrK10gID0gaGlnaCAmIDB4N2YgfCAoKGhpZ2ggPj4+PSA3KSA/IDB4ODAgOiAwKTsgaWYgKCFoaWdoKSByZXR1cm47CiAgICAgIHBiZi5idWZbcGJmLnBvcysrXSAgPSBoaWdoICYgMHg3ZiB8ICgoaGlnaCA+Pj49IDcpID8gMHg4MCA6IDApOyBpZiAoIWhpZ2gpIHJldHVybjsKICAgICAgcGJmLmJ1ZltwYmYucG9zKytdICA9IGhpZ2ggJiAweDdmOwogIH0KCiAgZnVuY3Rpb24gbWFrZVJvb21Gb3JFeHRyYUxlbmd0aChzdGFydFBvcywgbGVuLCBwYmYpIHsKICAgICAgdmFyIGV4dHJhTGVuID0KICAgICAgICAgIGxlbiA8PSAweDNmZmYgPyAxIDoKICAgICAgICAgIGxlbiA8PSAweDFmZmZmZiA/IDIgOgogICAgICAgICAgbGVuIDw9IDB4ZmZmZmZmZiA/IDMgOiBNYXRoLmZsb29yKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7CgogICAgICAvLyBpZiAxIGJ5dGUgaXNuJ3QgZW5vdWdoIGZvciBlbmNvZGluZyBtZXNzYWdlIGxlbmd0aCwgc2hpZnQgdGhlIGRhdGEgdG8gdGhlIHJpZ2h0CiAgICAgIHBiZi5yZWFsbG9jKGV4dHJhTGVuKTsKICAgICAgZm9yICh2YXIgaSA9IHBiZi5wb3MgLSAxOyBpID49IHN0YXJ0UG9zOyBpLS0pIHBiZi5idWZbaSArIGV4dHJhTGVuXSA9IHBiZi5idWZbaV07CiAgfQoKICBmdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9CiAgZnVuY3Rpb24gd3JpdGVQYWNrZWRTVmFyaW50KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlU1ZhcmludChhcnJbaV0pOyAgfQogIGZ1bmN0aW9uIHdyaXRlUGFja2VkRmxvYXQoYXJyLCBwYmYpICAgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZsb2F0KGFycltpXSk7ICAgIH0KICBmdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9CiAgZnVuY3Rpb24gd3JpdGVQYWNrZWRCb29sZWFuKGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlQm9vbGVhbihhcnJbaV0pOyAgfQogIGZ1bmN0aW9uIHdyaXRlUGFja2VkRml4ZWQzMihhcnIsIHBiZikgIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZUZpeGVkMzIoYXJyW2ldKTsgIH0KICBmdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9CiAgZnVuY3Rpb24gd3JpdGVQYWNrZWRGaXhlZDY0KGFyciwgcGJmKSAgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcGJmLndyaXRlRml4ZWQ2NChhcnJbaV0pOyAgfQogIGZ1bmN0aW9uIHdyaXRlUGFja2VkU0ZpeGVkNjQoYXJyLCBwYmYpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHBiZi53cml0ZVNGaXhlZDY0KGFycltpXSk7IH0KCiAgLy8gQnVmZmVyIGNvZGUgYmVsb3cgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlciwgTUlULWxpY2Vuc2VkCgogIGZ1bmN0aW9uIHJlYWRVSW50MzIoYnVmLCBwb3MpIHsKICAgICAgcmV0dXJuICgoYnVmW3Bvc10pIHwKICAgICAgICAgIChidWZbcG9zICsgMV0gPDwgOCkgfAogICAgICAgICAgKGJ1Zltwb3MgKyAyXSA8PCAxNikpICsKICAgICAgICAgIChidWZbcG9zICsgM10gKiAweDEwMDAwMDApOwogIH0KCiAgZnVuY3Rpb24gd3JpdGVJbnQzMihidWYsIHZhbCwgcG9zKSB7CiAgICAgIGJ1Zltwb3NdID0gdmFsOwogICAgICBidWZbcG9zICsgMV0gPSAodmFsID4+PiA4KTsKICAgICAgYnVmW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpOwogICAgICBidWZbcG9zICsgM10gPSAodmFsID4+PiAyNCk7CiAgfQoKICBmdW5jdGlvbiByZWFkSW50MzIoYnVmLCBwb3MpIHsKICAgICAgcmV0dXJuICgoYnVmW3Bvc10pIHwKICAgICAgICAgIChidWZbcG9zICsgMV0gPDwgOCkgfAogICAgICAgICAgKGJ1Zltwb3MgKyAyXSA8PCAxNikpICsKICAgICAgICAgIChidWZbcG9zICsgM10gPDwgMjQpOwogIH0KCiAgZnVuY3Rpb24gcmVhZFV0ZjgoYnVmLCBwb3MsIGVuZCkgewogICAgICB2YXIgc3RyID0gJyc7CiAgICAgIHZhciBpID0gcG9zOwoKICAgICAgd2hpbGUgKGkgPCBlbmQpIHsKICAgICAgICAgIHZhciBiMCA9IGJ1ZltpXTsKICAgICAgICAgIHZhciBjID0gbnVsbDsgLy8gY29kZXBvaW50CiAgICAgICAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9CiAgICAgICAgICAgICAgYjAgPiAweEVGID8gNCA6CiAgICAgICAgICAgICAgYjAgPiAweERGID8gMyA6CiAgICAgICAgICAgICAgYjAgPiAweEJGID8gMiA6IDE7CgogICAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlID4gZW5kKSBicmVhazsKCiAgICAgICAgICB2YXIgYjEsIGIyLCBiMzsKCiAgICAgICAgICBpZiAoYnl0ZXNQZXJTZXF1ZW5jZSA9PT0gMSkgewogICAgICAgICAgICAgIGlmIChiMCA8IDB4ODApIHsKICAgICAgICAgICAgICAgICAgYyA9IGIwOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZXNQZXJTZXF1ZW5jZSA9PT0gMikgewogICAgICAgICAgICAgIGIxID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICBpZiAoKGIxICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgICAgICAgYyA9IChiMCAmIDB4MUYpIDw8IDB4NiB8IChiMSAmIDB4M0YpOwogICAgICAgICAgICAgICAgICBpZiAoYyA8PSAweDdGKSB7CiAgICAgICAgICAgICAgICAgICAgICBjID0gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZXNQZXJTZXF1ZW5jZSA9PT0gMykgewogICAgICAgICAgICAgIGIxID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICBiMiA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgaWYgKChiMSAmIDB4QzApID09PSAweDgwICYmIChiMiAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgICAgICAgIGMgPSAoYjAgJiAweEYpIDw8IDB4QyB8IChiMSAmIDB4M0YpIDw8IDB4NiB8IChiMiAmIDB4M0YpOwogICAgICAgICAgICAgICAgICBpZiAoYyA8PSAweDdGRiB8fCAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERGRkYpKSB7CiAgICAgICAgICAgICAgICAgICAgICBjID0gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoYnl0ZXNQZXJTZXF1ZW5jZSA9PT0gNCkgewogICAgICAgICAgICAgIGIxID0gYnVmW2kgKyAxXTsKICAgICAgICAgICAgICBiMiA9IGJ1ZltpICsgMl07CiAgICAgICAgICAgICAgYjMgPSBidWZbaSArIDNdOwogICAgICAgICAgICAgIGlmICgoYjEgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkgewogICAgICAgICAgICAgICAgICBjID0gKGIwICYgMHhGKSA8PCAweDEyIHwgKGIxICYgMHgzRikgPDwgMHhDIHwgKGIyICYgMHgzRikgPDwgMHg2IHwgKGIzICYgMHgzRik7CiAgICAgICAgICAgICAgICAgIGlmIChjIDw9IDB4RkZGRiB8fCBjID49IDB4MTEwMDAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBjID0gbnVsbDsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoYyA9PT0gbnVsbCkgewogICAgICAgICAgICAgIGMgPSAweEZGRkQ7CiAgICAgICAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7CgogICAgICAgICAgfSBlbHNlIGlmIChjID4gMHhGRkZGKSB7CiAgICAgICAgICAgICAgYyAtPSAweDEwMDAwOwogICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApOwogICAgICAgICAgICAgIGMgPSAweERDMDAgfCBjICYgMHgzRkY7CiAgICAgICAgICB9CgogICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7CiAgICAgICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7CiAgICAgIH0KCiAgICAgIHJldHVybiBzdHI7CiAgfQoKICBmdW5jdGlvbiByZWFkVXRmOFRleHREZWNvZGVyKGJ1ZiwgcG9zLCBlbmQpIHsKICAgICAgcmV0dXJuIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUoYnVmLnN1YmFycmF5KHBvcywgZW5kKSk7CiAgfQoKICBmdW5jdGlvbiB3cml0ZVV0ZjgoYnVmLCBzdHIsIHBvcykgewogICAgICBmb3IgKHZhciBpID0gMCwgYywgbGVhZDsgaSA8IHN0ci5sZW5ndGg7IGkrKykgewogICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBjb2RlIHBvaW50CgogICAgICAgICAgaWYgKGMgPiAweEQ3RkYgJiYgYyA8IDB4RTAwMCkgewogICAgICAgICAgICAgIGlmIChsZWFkKSB7CiAgICAgICAgICAgICAgICAgIGlmIChjIDwgMHhEQzAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBidWZbcG9zKytdID0gMHhFRjsKICAgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSAweEJGOwogICAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkQ7CiAgICAgICAgICAgICAgICAgICAgICBsZWFkID0gYzsKICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDsKICAgICAgICAgICAgICAgICAgICAgIGxlYWQgPSBudWxsOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgaWYgKGMgPiAweERCRkYgfHwgKGkgKyAxID09PSBzdHIubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4RUY7CiAgICAgICAgICAgICAgICAgICAgICBidWZbcG9zKytdID0gMHhCRjsKICAgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSAweEJEOwogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7CiAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4RUY7CiAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkY7CiAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IDB4QkQ7CiAgICAgICAgICAgICAgbGVhZCA9IG51bGw7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKGMgPCAweDgwKSB7CiAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IGM7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChjIDwgMHg4MDApIHsKICAgICAgICAgICAgICAgICAgYnVmW3BvcysrXSA9IGMgPj4gMHg2IHwgMHhDMDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBpZiAoYyA8IDB4MTAwMDApIHsKICAgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4QyB8IDB4RTA7CiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBidWZbcG9zKytdID0gYyA+PiAweDEyIHwgMHhGMDsKICAgICAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4QyAmIDB4M0YgfCAweDgwOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBjID4+IDB4NiAmIDB4M0YgfCAweDgwOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBidWZbcG9zKytdID0gYyAmIDB4M0YgfCAweDgwOwogICAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBwb3M7CiAgfQoKICA7DQogIDsNCiAgLy90eXBlIEFyY2dpc1Jlc3RTb3VyY2VTcGVjaWZpY2F0aW9uID0gYW55Ow0KICB2YXIgZXNyaVBiZkdlb21ldHJ5VHlwZUVudW07DQogIChmdW5jdGlvbiAoZXNyaVBiZkdlb21ldHJ5VHlwZUVudW0pIHsNCiAgICAgIGVzcmlQYmZHZW9tZXRyeVR5cGVFbnVtW2VzcmlQYmZHZW9tZXRyeVR5cGVFbnVtWyJlc3JpR2VvbWV0cnlUeXBlUG9pbnQiXSA9IDBdID0gImVzcmlHZW9tZXRyeVR5cGVQb2ludCI7DQogICAgICBlc3JpUGJmR2VvbWV0cnlUeXBlRW51bVtlc3JpUGJmR2VvbWV0cnlUeXBlRW51bVsiZXNyaUdlb21ldHJ5VHlwZU11bHRpcG9pbnQiXSA9IDFdID0gImVzcmlHZW9tZXRyeVR5cGVNdWx0aXBvaW50IjsNCiAgICAgIGVzcmlQYmZHZW9tZXRyeVR5cGVFbnVtW2VzcmlQYmZHZW9tZXRyeVR5cGVFbnVtWyJlc3JpR2VvbWV0cnlUeXBlUG9seWxpbmUiXSA9IDJdID0gImVzcmlHZW9tZXRyeVR5cGVQb2x5bGluZSI7DQogICAgICBlc3JpUGJmR2VvbWV0cnlUeXBlRW51bVtlc3JpUGJmR2VvbWV0cnlUeXBlRW51bVsiZXNyaUdlb21ldHJ5VHlwZVBvbHlnb24iXSA9IDNdID0gImVzcmlHZW9tZXRyeVR5cGVQb2x5Z29uIjsNCiAgICAgIGVzcmlQYmZHZW9tZXRyeVR5cGVFbnVtW2VzcmlQYmZHZW9tZXRyeVR5cGVFbnVtWyJlc3JpR2VvbWV0cnlUeXBlTXVsdGlwYXRjaCJdID0gNF0gPSAiZXNyaUdlb21ldHJ5VHlwZU11bHRpcGF0Y2giOw0KICAgICAgZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bImVzcmlHZW9tZXRyeVR5cGVOb25lIl0gPSAxMjddID0gImVzcmlHZW9tZXRyeVR5cGVOb25lIjsNCiAgfSkoZXNyaVBiZkdlb21ldHJ5VHlwZUVudW0gfHwgKGVzcmlQYmZHZW9tZXRyeVR5cGVFbnVtID0ge30pKTsNCiAgOwoKICBjbGFzcyBDb252ZXJ0UGJmIHsNCiAgICAgIGNvbnN0cnVjdG9yKHBiZkRhdGEpIHsNCiAgICAgICAgICB0aGlzLmRhdGEgPSBwYmZEYXRhOw0KICAgICAgfQ0KICAgICAgYXN5bmMgY29udmVydCgpIHsNCiAgICAgICAgICB2YXIgX2E7DQogICAgICAgICAgY29uc3QgcGJmJDEgPSBuZXcgcGJmKHRoaXMuZGF0YSk7DQogICAgICAgICAgY29uc3QgcGJmSnNvbiA9IHByb3RvKCkucmVhZChwYmYkMSk7DQogICAgICAgICAgLy8gR2V0IHRoZSBGZWF0dXJlUmVzdWx0DQogICAgICAgICAgaWYgKHBiZkpzb24ucXVlcnlSZXN1bHQgPT09IG51bGwpIHsNCiAgICAgICAgICAgICAgLy9jb25zb2xlLndhcm4oJ2lzc3VlIHdpdGggdGhlIHJlc3VsdCcsIHBiZkpzb24pOw0KICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZXNwb25zZSh7DQogICAgICAgICAgICAgICAgICAnZXhjZWVkZWRUcmFuc2ZlckxpbWl0JzogdHJ1ZSwNCiAgICAgICAgICAgICAgfSwgW10pOw0KICAgICAgICAgIH0NCiAgICAgICAgICBjb25zdCBmZWF0dXJlUmVzdWx0ID0gcGJmSnNvbi5xdWVyeVJlc3VsdC5mZWF0dXJlUmVzdWx0Ow0KICAgICAgICAgIC8vIEdldCB0aGUgZmllbGQgbmFtZXMNCiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBmZWF0dXJlUmVzdWx0LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiBmaWVsZC5uYW1lKTsNCiAgICAgICAgICAvLyBHZXQgdGhlIHRyYW5zbGF0aW9uIGluZm8NCiAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IGZlYXR1cmVSZXN1bHQudHJhbnNmb3JtLnRyYW5zbGF0ZTsNCiAgICAgICAgICBjb25zdCBzY2FsZSA9IGZlYXR1cmVSZXN1bHQudHJhbnNmb3JtLnNjYWxlOw0KICAgICAgICAgIGNvbnN0IGdlb21ldHJ5VHlwZSA9IGZlYXR1cmVSZXN1bHQuZ2VvbWV0cnlUeXBlOw0KICAgICAgICAgIGNvbnN0IHF1YW50aXplT3JpZ2luUG9zdGlvbiA9IGZlYXR1cmVSZXN1bHQudHJhbnNmb3JtLnF1YW50aXplT3JpZ2luUG9zdGlvbjsNCiAgICAgICAgICBjb25zdCBzcmlkID0gKF9hID0gZmVhdHVyZVJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2tpZC50b1N0cmluZygpOw0KICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gZmVhdHVyZVJlc3VsdC5mZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHsNCiAgICAgICAgICAgICAgLy8gUGFyc2UgZWFjaCBhdHRyaWJ1dGUNCiAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZXMgPSBmZWF0dXJlLmF0dHJpYnV0ZXMNCiAgICAgICAgICAgICAgICAgIC5tYXAoKGF0dHJpYnV0ZSwgaW5kZXgpID0+ICh7ICdrZXknOiBmaWVsZHNbaW5kZXhdLCAndmFsdWUnOiBhdHRyaWJ1dGVbYXR0cmlidXRlWyd2YWx1ZV90eXBlJ11dIH0pKQ0KICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYSwgYykgPT4gew0KICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T2JqID0ge307DQogICAgICAgICAgICAgICAgICBuZXdPYmpbYy5rZXldID0gYy52YWx1ZTsNCiAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmEsIC4uLm5ld09iaiB9Ow0KICAgICAgICAgICAgICB9LCB7fSk7DQogICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBnZW9tZXRyaWVzIGFuZCBjbGVhbiB1cCB0aGUgcXVhbnRpemF0aW9uDQogICAgICAgICAgICAgIGxldCByaW5ncyA9IFtbW11dXTsNCiAgICAgICAgICAgICAgaWYgKChmZWF0dXJlLmdlb21ldHJ5ICE9PSBudWxsKSkgew0KICAgICAgICAgICAgICAgICAgbGV0IGNvdW50cyA9IGdlb21ldHJ5VHlwZSA9PT0gZXNyaVBiZkdlb21ldHJ5VHlwZUVudW0uZXNyaUdlb21ldHJ5VHlwZVBvaW50ID8gWzFdIDogKGZlYXR1cmUuZ2VvbWV0cnkubGVuZ3Rocyk7DQogICAgICAgICAgICAgICAgICAvLyBCcmVhayBpbnRvIFggYW5kIFkgcmluZ3MNCiAgICAgICAgICAgICAgICAgIGxldCB4ID0gW107DQogICAgICAgICAgICAgICAgICBsZXQgeSA9IFtdOw0KICAgICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZHMuZm9yRWFjaCgoY29vcmQsIGlkeCkgPT4gew0KICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggJSAyID09PSAwKSB7DQogICAgICAgICAgICAgICAgICAgICAgICAgIHgucHVzaChjb29yZCk7DQogICAgICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgICAgICB5LnB1c2goY29vcmQpOw0KICAgICAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgIH0pOw0KICAgICAgICAgICAgICAgICAgLy9sZXQgeCA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRzLmZpbHRlcigoXzogbnVtYmVyLCBpZHg6IG51bWJlcikgPT4gaWR4ICUgMiA9PT0gMCk7DQogICAgICAgICAgICAgICAgICAvL2xldCB5ID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZHMuZmlsdGVyKChfOiBudW1iZXIsIGlkeDogbnVtYmVyKSA9PiBpZHggJSAyID09PSAxKTsNCiAgICAgICAgICAgICAgICAgIC8vIGRlemlnemFnIHRoZSByaW5ncywgYW5kIG1lcmdlICsgcmVwcm9qZWN0IHRoZW0NCiAgICAgICAgICAgICAgICAgIGxldCByaW5nc1ggPSBkZVppZ1phZyh4LCBjb3VudHMsIHNjYWxlLnhTY2FsZSwgdHJhbnNsYXRpb24ueFRyYW5zbGF0ZSwgZmFsc2UpOw0KICAgICAgICAgICAgICAgICAgbGV0IHJpbmdzWSA9IGRlWmlnWmFnKHksIGNvdW50cywgc2NhbGUueVNjYWxlLCB0cmFuc2xhdGlvbi55VHJhbnNsYXRlLCBxdWFudGl6ZU9yaWdpblBvc3Rpb24gPT09IDApOw0KICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHJpbmdzDQogICAgICAgICAgICAgICAgICByaW5ncyA9IG1lcmdlUmluZ3MocmluZ3NYLCByaW5nc1ksIHNyaWQpOw0KICAgICAgICAgICAgICAgICAgLy9yaW5ncyA9IHJpbmdzWC5tYXAoKHJpbmcsIGkpID0+IHJpbmcubWFwKCh4LCBqKSA9PiBbeCwgcmluZ3NZW2ldW2pdXSkpOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIGxldCBnZW9tZXRyeSA9IHt9Ow0KICAgICAgICAgICAgICBpZiAoZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bZ2VvbWV0cnlUeXBlXSA9PT0gJ2VzcmlHZW9tZXRyeVR5cGVQb2ludCcpIHsNCiAgICAgICAgICAgICAgICAgIGdlb21ldHJ5ID0geyAneCc6IHJpbmdzWzBdWzBdWzBdLCAneSc6IHJpbmdzWzBdWzBdWzFdIH07DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgZWxzZSBpZiAoZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bZ2VvbWV0cnlUeXBlXSA9PT0gJ2VzcmlHZW9tZXRyeVR5cGVNdWx0aVBvaW50Jykgew0KICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSB7ICdwb2ludHMnOiByaW5nc1swXSB9Ow0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIGVsc2UgaWYgKGVzcmlQYmZHZW9tZXRyeVR5cGVFbnVtW2dlb21ldHJ5VHlwZV0gPT09ICdlc3JpR2VvbWV0cnlUeXBlUG9seWxpbmUnKSB7DQogICAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IHsgcGF0aHM6IHJpbmdzIH07DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgZWxzZSBpZiAoZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bZ2VvbWV0cnlUeXBlXSA9PT0gJ2VzcmlHZW9tZXRyeVR5cGVQb2x5Z29uJykgew0KICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSB7IHJpbmdzOiByaW5ncyB9Ow0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICAgICAnZ2VvbWV0cnknOiBnZW9tZXRyeSwNCiAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGVzJzogYXR0cmlidXRlcywNCiAgICAgICAgICAgICAgfTsNCiAgICAgICAgICB9KTsNCiAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRSZXNwb25zZShmZWF0dXJlUmVzdWx0LCBmZWF0dXJlcyk7DQogICAgICB9DQogICAgICBfYnVpbGRSZXNwb25zZShmZWF0dXJlUmVzdWx0LCBmZWF0dXJlcykgew0KICAgICAgICAgIHJldHVybiB7DQogICAgICAgICAgICAgICdmZWF0dXJlcyc6IGZlYXR1cmVzLA0KICAgICAgICAgICAgICAnZXhjZWVkZWRUcmFuc2ZlckxpbWl0JzogZmVhdHVyZVJlc3VsdC5leGNlZWRlZFRyYW5zZmVyTGltaXQsDQogICAgICAgICAgICAgICdzcGF0aWFsUmVmZXJlbmNlJzogeyAnd2tpZCc6IDQzMjYsICdsYXRlc3RXa2lkJzogNDMyNiB9LA0KICAgICAgICAgICAgICAnZ2VvbWV0cnlUeXBlJzogZXNyaVBiZkdlb21ldHJ5VHlwZUVudW1bZmVhdHVyZVJlc3VsdC5nZW9tZXRyeVR5cGUgfHwgMTI3XS5yZXBsYWNlKCdUeXBlJywgJycpLA0KICAgICAgICAgICAgICAnaGFzTSc6IGZlYXR1cmVSZXN1bHQuaGFzTSwNCiAgICAgICAgICAgICAgJ2hhc1onOiBmZWF0dXJlUmVzdWx0Lmhhc1osDQogICAgICAgICAgICAgICdnbG9iYWxJZEZpZWxkTmFtZSc6IGZlYXR1cmVSZXN1bHQuZ2xvYmFsSWRGaWVsZE5hbWUNCiAgICAgICAgICB9Ow0KICAgICAgfQ0KICB9DQogIDsKCiAgY2xhc3MgR2VvbWV0cmllc0F0Wm9vbSB7DQogICAgICBjb25zdHJ1Y3RvcigpIHsNCiAgICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgZ2VvbWV0cmllcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGxvYWRlZA0KICAgICAgICAgIHRoaXMuX2dlb21ldHJpZXNBdFpvb20gPSBuZXcgQXJyYXkoMjQpOw0KICAgICAgICAgIHRoaXMuX21heEdlb21ldHJ5Wm9vbSA9IDA7DQogICAgICB9DQogICAgICBhc3luYyBnZXRLZXlzQXRab29tKHpvb20sIG1heFpvb20pIHsNCiAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG1heCB6b29tIGJhc2VkIG9uIHRoZSB1c2VyIGlucHV0LCB0aGUgbWFwJ3MgbWF4em9vbSwgb3IgdGhlIG1heHpvb20gd2UgaGF2ZSBjYWNoZWQNCiAgICAgICAgICBtYXhab29tID0gbWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gbWF4Wm9vbSA6IHRoaXMuX21heEdlb21ldHJ5Wm9vbTsNCiAgICAgICAgICBjb25zdCBnZW9tZXRyeUdyb3VwcyA9IFtdOw0KICAgICAgICAgIGZvciAobGV0IHogPSAoTWF0aC5taW4obWF4Wm9vbSwgdGhpcy5fbWF4R2VvbWV0cnlab29tKSk7IHogPj0gem9vbTsgei0tKSB7DQogICAgICAgICAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzQXRab29tW3pdICE9PSB1bmRlZmluZWQpIHsNCiAgICAgICAgICAgICAgICAgIGdlb21ldHJ5R3JvdXBzLnB1c2goWy4uLnRoaXMuX2dlb21ldHJpZXNBdFpvb21bel0ua2V5cygpXSk7DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICB9DQogICAgICAgICAgcmV0dXJuIGdlb21ldHJ5R3JvdXBzLmZsYXQoKTsNCiAgICAgIH0NCiAgICAgIHVwZGF0ZUtleUF0Wm9vbSh6b29tLCBwcmltYXJ5S2V5KSB7DQogICAgICAgICAgbGV0IHJldHVyblZhbHVlID0gJ2FkZGVkJzsNCiAgICAgICAgICBpZiAodGhpcy5fZ2VvbWV0cmllc0F0Wm9vbVt6b29tXSA9PT0gdW5kZWZpbmVkKQ0KICAgICAgICAgICAgICB0aGlzLl9nZW9tZXRyaWVzQXRab29tW3pvb21dID0gbmV3IE1hcCgpOw0KICAgICAgICAgIHRoaXMuX21heEdlb21ldHJ5Wm9vbSA9IE1hdGgubWF4KHRoaXMuX21heEdlb21ldHJ5Wm9vbSwgem9vbSk7DQogICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB6b29tOyB6KyspIHsNCiAgICAgICAgICAgICAgaWYgKHRoaXMuX2dlb21ldHJpZXNBdFpvb21bel0gIT09IHVuZGVmaW5lZCkgew0KICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cmllc0F0Wm9vbVt6XS5kZWxldGUocHJpbWFyeUtleSk7DQogICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICd1cGRhdGVkJzsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgIH0NCiAgICAgICAgICB0aGlzLl9nZW9tZXRyaWVzQXRab29tW3pvb21dLnNldChwcmltYXJ5S2V5LCB0cnVlKTsNCiAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7DQogICAgICB9DQogICAgICBhc3luYyB1cGRhdGVLZXlzQXRab29tKHpvb20sIHByaW1hcnlLZXlzKSB7DQogICAgICAgICAgcmV0dXJuIHByaW1hcnlLZXlzLm1hcChwcmltYXJ5S2V5ID0+IHRoaXMudXBkYXRlS2V5QXRab29tKHpvb20sIHByaW1hcnlLZXkpKTsNCiAgICAgIH0NCiAgfQoKICBjb25zdCBsaWJyYXJpZXMgPSB7DQogICAgICAnQ29udmVydFBiZic6IENvbnZlcnRQYmYsDQogICAgICAnR2VvbWV0cmllc0F0Wm9vbSc6IEdlb21ldHJpZXNBdFpvb20sDQogICAgICAnRGVaaWdaYWdKU09OJzogRGVaaWdaYWdKU09ODQogIH07DQogIGNvbnN0IHN1YkNsYXNzZXMgPSBPYmplY3Qua2V5cyhsaWJyYXJpZXMpOw0KICBsZXQgc3ViQ2xhc3M7DQogIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGUgPT4gew0KICAgICAgY29uc3QgZGF0YSA9IChlLmRhdGEgfHwgZSk7DQogICAgICBjb25zdCBwb3N0ID0gKGlkLCBlcnIsIHJlcywgdHlwZSkgPT4gew0KICAgICAgICAgIHBvc3RNZXNzYWdlKHsNCiAgICAgICAgICAgICAgdHlwZTogdHlwZSA/IHR5cGUgOiAoZXJyID8gJ2Vycm9yJyA6ICdyZXNwb25zZScpLA0KICAgICAgICAgICAgICBpZDogaWQsDQogICAgICAgICAgICAgIG1lc3NhZ2U6IHJlcywNCiAgICAgICAgICAgICAgZXJyb3I6IGVycg0KICAgICAgICAgIH0pOw0KICAgICAgfTsNCiAgICAgIGNvbnN0IGNvbW1hbmRzID0gew0KICAgICAgICAgICdpbml0JzogKG1zZykgPT4gew0KICAgICAgICAgICAgICBjb25zdCB7IGlkLCBjb21tYW5kLCBtZXNzYWdlIH0gPSBtc2c7DQogICAgICAgICAgICAgIHN1YkNsYXNzID0gbmV3IGxpYnJhcmllc1tjb21tYW5kXSguLi5tZXNzYWdlKTsNCiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBjbGFzcycgbWV0aG9kcw0KICAgICAgICAgICAgICBjb25zdCBmbnMgPSBbDQogICAgICAgICAgICAgICAgICAuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhsaWJyYXJpZXNbY29tbWFuZF0ucHJvdG90eXBlKSwNCiAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKHN1YkNsYXNzKQ0KICAgICAgICAgICAgICBdLm1hcChrZXkgPT4gW2tleSwgdHlwZW9mIGxpYnJhcmllc1tjb21tYW5kXS5wcm90b3R5cGVba2V5XV0pDQogICAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBjKSA9PiAoeyAuLi5hLCAuLi57IFtjWzBdXTogY1sxXSB9IH0pLCB7fSk7DQogICAgICAgICAgICAgIHBvc3QoaWQsIHVuZGVmaW5lZCwgZm5zLCAnaW5pdF9yZXNwb25zZScpOw0KICAgICAgICAgIH0sDQogICAgICAgICAgJ2dldCc6IGZ1bmN0aW9uIChtc2cpIHsNCiAgICAgICAgICAgICAgY29uc3QgeyBpZCwgY29tbWFuZCB9ID0gbXNnOw0KICAgICAgICAgICAgICBpZiAoc3ViQ2xhc3MgJiYgc3ViQ2xhc3NbY29tbWFuZF0pIHsNCiAgICAgICAgICAgICAgICAgIHBvc3QoaWQsIHVuZGVmaW5lZCwgc3ViQ2xhc3NbY29tbWFuZF0pOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgcG9zdChpZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgfSwNCiAgICAgICAgICAnZXhlYyc6IGZ1bmN0aW9uIChtc2cpIHsNCiAgICAgICAgICAgICAgY29uc3QgeyBpZCwgY29tbWFuZCwgbWVzc2FnZSB9ID0gbXNnOw0KICAgICAgICAgICAgICBpZiAoc3ViQ2xhc3MgJiYgc3ViQ2xhc3NbY29tbWFuZF0gJiYgdHlwZW9mIHN1YkNsYXNzW2NvbW1hbmRdID09PSAnZnVuY3Rpb24nKSB7DQogICAgICAgICAgICAgICAgICBjb25zdCBjbWQgPSBzdWJDbGFzc1tjb21tYW5kXQ0KICAgICAgICAgICAgICAgICAgICAgIC5hcHBseShzdWJDbGFzcywgbWVzc2FnZSk7DQogICAgICAgICAgICAgICAgICBpZiAoISFjbWQgJiYgdHlwZW9mIGNtZC50aGVuID09PSAnZnVuY3Rpb24nKSB7DQogICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBhIHByb21pc2UsIHNvIHdhaXQgZm9yIGl0DQogICAgICAgICAgICAgICAgICAgICAgY21kDQogICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiBwb3N0KGlkLCB1bmRlZmluZWQsIHJlcykpDQogICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHBvc3QoaWQsIGUpKTsNCiAgICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhIHByb21pc2UsIGp1c3QgcmV0dXJuIGl0DQogICAgICAgICAgICAgICAgICAgICAgcG9zdChpZCwgdW5kZWZpbmVkLCBjbWQpOw0KICAgICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIGVsc2Ugew0KICAgICAgICAgICAgICAgICAgLy8gRXJyb3INCiAgICAgICAgICAgICAgICAgIHBvc3QoaWQsIG5ldyBFcnJvcihgY29tbWFuZCAiJHtjb21tYW5kfSIgbm90IGZvdW5kYCkpOw0KICAgICAgICAgICAgICB9DQogICAgICAgICAgfQ0KICAgICAgfTsNCiAgICAgIGlmIChjb21tYW5kc1tkYXRhLnR5cGVdKSB7DQogICAgICAgICAgY29tbWFuZHNbZGF0YS50eXBlXShkYXRhKTsNCiAgICAgIH0NCiAgfSk7CgogIGV4cG9ydHMubGlicmFyaWVzID0gbGlicmFyaWVzOwoKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pOwoKICByZXR1cm4gZXhwb3J0czsKCn0pKHt9KTsKCg==', null, false);
  /* eslint-enable */

  const earthCircumference = 40075016.68557849;
  /**
    * Converts a webmercator x,y to WGS84 lng,lat
    * @param x
    * @param y
    * @returns LngLngLike
    */
  function toWGS84(x, y) {
      // Convert the lat lng
      const wgsLng = x * 180 / (earthCircumference / 2);
      // thanks magichim @ github for the correction
      const wgsLat = Math.atan(Math.exp(y * Math.PI / (earthCircumference / 2))) * 360 / Math.PI - 90;
      return { lng: wgsLng, lat: wgsLat };
  }
  ;
  /**
   * Converts a WGS84 lng,lat to webmercator x,y
   * @param lng
   * @param lat
   * @returns {x: number, y: number}
   */
  function fromWGS84(lng, lat) {
      // Calculate the web mercator X and Y
      // https://gist.github.com/onderaltintas/6649521
      const wmx = lng * (earthCircumference / 2) / 180;
      let wmy = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
      wmy = wmy * (earthCircumference / 2) / 180;
      return { x: wmx, y: wmy };
  }
  ;
  /**
   * Takes a zoom, returns WebMercator Meters Per Pixel
   * Adapted from: https://github.com/mapbox/postgis-vt-util/blob/master/src/ZRes.sql
   * @param zoom
   * @param tileSize is optional, default is 256 (for 256x256 tiles)
   * @returns number
   */
  function metersPerPixel(zoom, tileSize = 256) {
      return earthCircumference / (tileSize * (1 << zoom));
  }

  const webMercatorCodes = ['102100', '900913', '3857', '3587', '54004', '41001', '102113', '3785'];
  function getEsriBoundingBox(lngLatBbox) {
      const sw = [Math.min(lngLatBbox[0], lngLatBbox[2]), Math.min(lngLatBbox[1], lngLatBbox[3])];
      const ne = [Math.max(lngLatBbox[0], lngLatBbox[2]), Math.max(lngLatBbox[1], lngLatBbox[3])];
      let swXY = fromWGS84(sw[0], sw[1]);
      let neXY = fromWGS84(ne[0], ne[1]);
      return {
          'type': 'extent',
          'xmin': swXY.x,
          'ymin': swXY.y,
          'xmax': neXY.x,
          'ymax': neXY.y,
          'spatialReferece': {
              'latestWkid': 102100,
              'wkid': 3857
          }
      };
  }
  ;
  function quantizationParameters(tileZoomLevel, tileSize = 256) {
      return {
          mode: 'view',
          originPosition: 'upperLeft',
          tolerance: metersPerPixel(tileZoomLevel, tileSize),
          extent: getEsriBoundingBox([-180.0, -85.06, 180, 85.06])
      };
  }
  ;
  function mergeRings(ringsX, ringsY, srid) {
      const reproject = (x, y) => {
          const xy = toWGS84(x, y);
          return [xy.lng, xy.lat];
      };
      if (webMercatorCodes.indexOf(srid) > -1) {
          return ringsX.map((ring, i) => ring.map((x, j) => reproject(x, ringsY[i][j])));
      }
      else {
          return ringsX.map((ring, i) => ring.map((x, j) => [x, ringsY[i][j]]));
      }
  }
  ;
  function deZigZag(values, splits, scale, initialOffset, upperLeftOrigin) {
      return splits.map((split, i) => {
          let lastValue = 0;
          return Array(split).fill(undefined).map((_, j) => {
              const valueOffset = splits.reduce((a, v, idx) => a += (idx < i ? v : 0), 0);
              const value = values[valueOffset + j];
              const sign = upperLeftOrigin ? -1 : 1;
              let returnValue;
              if (j === 0) {
                  returnValue = (value * sign) + (initialOffset / scale);
              }
              else {
                  returnValue = (value * sign) + lastValue;
              }
              lastValue = returnValue;
              return returnValue;
          }).map((v) => v * scale);
      });
  }
  class DeZigZagJSON {
      constructor(features, transform, geometryType) {
          this.srid = '3857';
          this.features = features;
          this.transform = transform;
          this.geometryType = geometryType;
      }
      async convert() {
          return this.features.map(feature => {
              feature.geometry = this.convertGeometry(feature.geometry);
              return feature;
          });
      }
      convertGeometry(geometry) {
          const counts = [];
          const x = [];
          const y = [];
          if (this.geometryType === 'esriGeometryPoint') {
              counts.push(1);
              x.push(geometry.x);
              y.push(geometry.y);
          }
          else if (this.geometryType === 'esriGeometryMultipoint') {
              geometry.points.forEach(p => {
                  counts.push(1);
                  x.push(p[0]);
                  y.push(p[1]);
              });
          }
          else if (this.geometryType === 'esriGeometryPolyline') {
              geometry.paths.forEach(l => {
                  counts.push(l.length);
                  l.forEach(position => {
                      x.push(position[0]);
                      y.push(position[1]);
                  });
              });
          }
          else if (this.geometryType === 'esriGeometryPolygon') {
              geometry.rings.forEach(poly => {
                  counts.push(poly.length);
                  poly.forEach(position => {
                      x.push(position[0]);
                      y.push(position[1]);
                  });
              });
          }
          // dezigzag the rings, and merge + reproject them
          const ringsX = deZigZag(x, counts, this.transform.scale[0], this.transform.translate[0], false);
          const ringsY = deZigZag(y, counts, this.transform.scale[1], this.transform.translate[1], this.transform.originPosition === 'upperLeft');
          // Merge the rings
          const rings = mergeRings(ringsX, ringsY, this.srid);
          let newGeometry = {};
          if (this.geometryType === 'esriGeometryPoint') {
              newGeometry = { 'x': rings[0][0][0], 'y': rings[0][0][1] };
          }
          else if (this.geometryType === 'esriGeometryMultipoint') {
              newGeometry = { 'points': rings[0] };
          }
          else if (this.geometryType === 'esriGeometryPolyline') {
              newGeometry = { paths: rings };
          }
          else if (this.geometryType === 'esriGeometryPolygon') {
              newGeometry = { rings: rings };
          }
          return newGeometry;
      }
  }

  'use strict'; // code generated by pbf v3.2.1
  // FeatureCollectionPBuffer ========================================
  function proto () {
      let FeatureCollectionPBuffer = {};
      FeatureCollectionPBuffer.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer._readField, { version: "", queryResult: null }, end);
      };
      FeatureCollectionPBuffer._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.version = pbf.readString();
          else if (tag === 2)
              obj.queryResult = FeatureCollectionPBuffer.QueryResult.read(pbf, pbf.readVarint() + pbf.pos);
      };
      FeatureCollectionPBuffer.write = function (obj, pbf) {
          if (obj.version)
              pbf.writeStringField(1, obj.version);
          if (obj.queryResult)
              pbf.writeMessage(2, FeatureCollectionPBuffer.QueryResult.write, obj.queryResult);
      };
      FeatureCollectionPBuffer.GeometryType = {
          "esriGeometryTypePoint": {
              "value": 0,
              "options": {}
          },
          "esriGeometryTypeMultipoint": {
              "value": 1,
              "options": {}
          },
          "esriGeometryTypePolyline": {
              "value": 2,
              "options": {}
          },
          "esriGeometryTypePolygon": {
              "value": 3,
              "options": {}
          },
          "esriGeometryTypeMultipatch": {
              "value": 4,
              "options": {}
          },
          "esriGeometryTypeNone": {
              "value": 127,
              "options": {}
          }
      };
      FeatureCollectionPBuffer.FieldType = {
          "esriFieldTypeSmallInteger": {
              "value": 0,
              "options": {}
          },
          "esriFieldTypeInteger": {
              "value": 1,
              "options": {}
          },
          "esriFieldTypeSingle": {
              "value": 2,
              "options": {}
          },
          "esriFieldTypeDouble": {
              "value": 3,
              "options": {}
          },
          "esriFieldTypeString": {
              "value": 4,
              "options": {}
          },
          "esriFieldTypeDate": {
              "value": 5,
              "options": {}
          },
          "esriFieldTypeOID": {
              "value": 6,
              "options": {}
          },
          "esriFieldTypeGeometry": {
              "value": 7,
              "options": {}
          },
          "esriFieldTypeBlob": {
              "value": 8,
              "options": {}
          },
          "esriFieldTypeRaster": {
              "value": 9,
              "options": {}
          },
          "esriFieldTypeGUID": {
              "value": 10,
              "options": {}
          },
          "esriFieldTypeGlobalID": {
              "value": 11,
              "options": {}
          },
          "esriFieldTypeXML": {
              "value": 12,
              "options": {}
          }
      };
      FeatureCollectionPBuffer.SQLType = {
          "sqlTypeBigInt": {
              "value": 0,
              "options": {}
          },
          "sqlTypeBinary": {
              "value": 1,
              "options": {}
          },
          "sqlTypeBit": {
              "value": 2,
              "options": {}
          },
          "sqlTypeChar": {
              "value": 3,
              "options": {}
          },
          "sqlTypeDate": {
              "value": 4,
              "options": {}
          },
          "sqlTypeDecimal": {
              "value": 5,
              "options": {}
          },
          "sqlTypeDouble": {
              "value": 6,
              "options": {}
          },
          "sqlTypeFloat": {
              "value": 7,
              "options": {}
          },
          "sqlTypeGeometry": {
              "value": 8,
              "options": {}
          },
          "sqlTypeGUID": {
              "value": 9,
              "options": {}
          },
          "sqlTypeInteger": {
              "value": 10,
              "options": {}
          },
          "sqlTypeLongNVarchar": {
              "value": 11,
              "options": {}
          },
          "sqlTypeLongVarbinary": {
              "value": 12,
              "options": {}
          },
          "sqlTypeLongVarchar": {
              "value": 13,
              "options": {}
          },
          "sqlTypeNChar": {
              "value": 14,
              "options": {}
          },
          "sqlTypeNVarchar": {
              "value": 15,
              "options": {}
          },
          "sqlTypeOther": {
              "value": 16,
              "options": {}
          },
          "sqlTypeReal": {
              "value": 17,
              "options": {}
          },
          "sqlTypeSmallInt": {
              "value": 18,
              "options": {}
          },
          "sqlTypeSqlXml": {
              "value": 19,
              "options": {}
          },
          "sqlTypeTime": {
              "value": 20,
              "options": {}
          },
          "sqlTypeTimestamp": {
              "value": 21,
              "options": {}
          },
          "sqlTypeTimestamp2": {
              "value": 22,
              "options": {}
          },
          "sqlTypeTinyInt": {
              "value": 23,
              "options": {}
          },
          "sqlTypeVarbinary": {
              "value": 24,
              "options": {}
          },
          "sqlTypeVarchar": {
              "value": 25,
              "options": {}
          }
      };
      FeatureCollectionPBuffer.QuantizeOriginPostion = {
          "upperLeft": {
              "value": 0,
              "options": {}
          },
          "lowerLeft": {
              "value": 1,
              "options": {}
          }
      };
      // FeatureCollectionPBuffer.SpatialReference ========================================
      FeatureCollectionPBuffer.SpatialReference = {};
      FeatureCollectionPBuffer.SpatialReference.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.SpatialReference._readField, { wkid: 0, lastestWkid: 0, vcsWkid: 0, latestVcsWkid: 0, wkt: "" }, end);
      };
      FeatureCollectionPBuffer.SpatialReference._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.wkid = pbf.readVarint();
          else if (tag === 2)
              obj.lastestWkid = pbf.readVarint();
          else if (tag === 3)
              obj.vcsWkid = pbf.readVarint();
          else if (tag === 4)
              obj.latestVcsWkid = pbf.readVarint();
          else if (tag === 5)
              obj.wkt = pbf.readString();
      };
      FeatureCollectionPBuffer.SpatialReference.write = function (obj, pbf) {
          if (obj.wkid)
              pbf.writeVarintField(1, obj.wkid);
          if (obj.lastestWkid)
              pbf.writeVarintField(2, obj.lastestWkid);
          if (obj.vcsWkid)
              pbf.writeVarintField(3, obj.vcsWkid);
          if (obj.latestVcsWkid)
              pbf.writeVarintField(4, obj.latestVcsWkid);
          if (obj.wkt)
              pbf.writeStringField(5, obj.wkt);
      };
      // FeatureCollectionPBuffer.Field ========================================
      FeatureCollectionPBuffer.Field = {};
      FeatureCollectionPBuffer.Field.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Field._readField, { name: "", fieldType: 0, alias: "", sqlType: 0, domain: "", defaultValue: "" }, end);
      };
      FeatureCollectionPBuffer.Field._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.name = pbf.readString();
          else if (tag === 2)
              obj.fieldType = pbf.readVarint();
          else if (tag === 3)
              obj.alias = pbf.readString();
          else if (tag === 4)
              obj.sqlType = pbf.readVarint();
          else if (tag === 5)
              obj.domain = pbf.readString();
          else if (tag === 6)
              obj.defaultValue = pbf.readString();
      };
      FeatureCollectionPBuffer.Field.write = function (obj, pbf) {
          if (obj.name)
              pbf.writeStringField(1, obj.name);
          if (obj.fieldType)
              pbf.writeVarintField(2, obj.fieldType);
          if (obj.alias)
              pbf.writeStringField(3, obj.alias);
          if (obj.sqlType)
              pbf.writeVarintField(4, obj.sqlType);
          if (obj.domain)
              pbf.writeStringField(5, obj.domain);
          if (obj.defaultValue)
              pbf.writeStringField(6, obj.defaultValue);
      };
      // FeatureCollectionPBuffer.Value ========================================
      FeatureCollectionPBuffer.Value = {};
      FeatureCollectionPBuffer.Value.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Value._readField, { string_value: "", value_type: null, float_value: 0, double_value: 0, sint_value: 0, uint_value: 0, int64_value: 0, uint64_value: 0, sint64_value: 0, bool_value: false }, end);
      };
      FeatureCollectionPBuffer.Value._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.string_value = pbf.readString(), obj.value_type = "string_value";
          else if (tag === 2)
              obj.float_value = pbf.readFloat(), obj.value_type = "float_value";
          else if (tag === 3)
              obj.double_value = pbf.readDouble(), obj.value_type = "double_value";
          else if (tag === 4)
              obj.sint_value = pbf.readSVarint(), obj.value_type = "sint_value";
          else if (tag === 5)
              obj.uint_value = pbf.readVarint(), obj.value_type = "uint_value";
          else if (tag === 6)
              obj.int64_value = pbf.readVarint(true), obj.value_type = "int64_value";
          else if (tag === 7)
              obj.uint64_value = pbf.readVarint(), obj.value_type = "uint64_value";
          else if (tag === 8)
              obj.sint64_value = pbf.readSVarint(), obj.value_type = "sint64_value";
          else if (tag === 9)
              obj.bool_value = pbf.readBoolean(), obj.value_type = "bool_value";
      };
      FeatureCollectionPBuffer.Value.write = function (obj, pbf) {
          if (obj.string_value)
              pbf.writeStringField(1, obj.string_value);
          if (obj.float_value)
              pbf.writeFloatField(2, obj.float_value);
          if (obj.double_value)
              pbf.writeDoubleField(3, obj.double_value);
          if (obj.sint_value)
              pbf.writeSVarintField(4, obj.sint_value);
          if (obj.uint_value)
              pbf.writeVarintField(5, obj.uint_value);
          if (obj.int64_value)
              pbf.writeVarintField(6, obj.int64_value);
          if (obj.uint64_value)
              pbf.writeVarintField(7, obj.uint64_value);
          if (obj.sint64_value)
              pbf.writeSVarintField(8, obj.sint64_value);
          if (obj.bool_value)
              pbf.writeBooleanField(9, obj.bool_value);
      };
      // FeatureCollectionPBuffer.Geometry ========================================
      FeatureCollectionPBuffer.Geometry = {};
      FeatureCollectionPBuffer.Geometry.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Geometry._readField, { lengths: [], coords: [] }, end);
      };
      FeatureCollectionPBuffer.Geometry._readField = function (tag, obj, pbf) {
          if (tag === 2)
              pbf.readPackedVarint(obj.lengths);
          else if (tag === 3)
              pbf.readPackedSVarint(obj.coords);
      };
      FeatureCollectionPBuffer.Geometry.write = function (obj, pbf) {
          if (obj.lengths)
              pbf.writePackedVarint(2, obj.lengths);
          if (obj.coords)
              pbf.writePackedSVarint(3, obj.coords);
      };
      // FeatureCollectionPBuffer.esriShapeBuffer ========================================
      FeatureCollectionPBuffer.esriShapeBuffer = {};
      FeatureCollectionPBuffer.esriShapeBuffer.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.esriShapeBuffer._readField, { bytes: null }, end);
      };
      FeatureCollectionPBuffer.esriShapeBuffer._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.bytes = pbf.readBytes();
      };
      FeatureCollectionPBuffer.esriShapeBuffer.write = function (obj, pbf) {
          if (obj.bytes)
              pbf.writeBytesField(1, obj.bytes);
      };
      // FeatureCollectionPBuffer.Feature ========================================
      FeatureCollectionPBuffer.Feature = {};
      FeatureCollectionPBuffer.Feature.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Feature._readField, { attributes: [], geometry: null, compressed_geometry: null, shapeBuffer: null, centroid: null }, end);
      };
      FeatureCollectionPBuffer.Feature._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.attributes.push(FeatureCollectionPBuffer.Value.read(pbf, pbf.readVarint() + pbf.pos));
          else if (tag === 2)
              obj.geometry = FeatureCollectionPBuffer.Geometry.read(pbf, pbf.readVarint() + pbf.pos), obj.compressed_geometry = "geometry";
          else if (tag === 3)
              obj.shapeBuffer = FeatureCollectionPBuffer.esriShapeBuffer.read(pbf, pbf.readVarint() + pbf.pos), obj.compressed_geometry = "shapeBuffer";
          else if (tag === 4)
              obj.centroid = FeatureCollectionPBuffer.Geometry.read(pbf, pbf.readVarint() + pbf.pos);
      };
      FeatureCollectionPBuffer.Feature.write = function (obj, pbf) {
          if (obj.attributes)
              for (var i = 0; i < obj.attributes.length; i++)
                  pbf.writeMessage(1, FeatureCollectionPBuffer.Value.write, obj.attributes[i]);
          if (obj.geometry)
              pbf.writeMessage(2, FeatureCollectionPBuffer.Geometry.write, obj.geometry);
          if (obj.shapeBuffer)
              pbf.writeMessage(3, FeatureCollectionPBuffer.esriShapeBuffer.write, obj.shapeBuffer);
          if (obj.centroid)
              pbf.writeMessage(4, FeatureCollectionPBuffer.Geometry.write, obj.centroid);
      };
      // FeatureCollectionPBuffer.UniqueIdField ========================================
      FeatureCollectionPBuffer.UniqueIdField = {};
      FeatureCollectionPBuffer.UniqueIdField.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.UniqueIdField._readField, { name: "", isSystemMaintained: false }, end);
      };
      FeatureCollectionPBuffer.UniqueIdField._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.name = pbf.readString();
          else if (tag === 2)
              obj.isSystemMaintained = pbf.readBoolean();
      };
      FeatureCollectionPBuffer.UniqueIdField.write = function (obj, pbf) {
          if (obj.name)
              pbf.writeStringField(1, obj.name);
          if (obj.isSystemMaintained)
              pbf.writeBooleanField(2, obj.isSystemMaintained);
      };
      // FeatureCollectionPBuffer.GeometryProperties ========================================
      FeatureCollectionPBuffer.GeometryProperties = {};
      FeatureCollectionPBuffer.GeometryProperties.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.GeometryProperties._readField, { shapeAreaFieldName: "", shapeLengthFieldName: "", units: "" }, end);
      };
      FeatureCollectionPBuffer.GeometryProperties._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.shapeAreaFieldName = pbf.readString();
          else if (tag === 2)
              obj.shapeLengthFieldName = pbf.readString();
          else if (tag === 3)
              obj.units = pbf.readString();
      };
      FeatureCollectionPBuffer.GeometryProperties.write = function (obj, pbf) {
          if (obj.shapeAreaFieldName)
              pbf.writeStringField(1, obj.shapeAreaFieldName);
          if (obj.shapeLengthFieldName)
              pbf.writeStringField(2, obj.shapeLengthFieldName);
          if (obj.units)
              pbf.writeStringField(3, obj.units);
      };
      // FeatureCollectionPBuffer.ServerGens ========================================
      FeatureCollectionPBuffer.ServerGens = {};
      FeatureCollectionPBuffer.ServerGens.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.ServerGens._readField, { minServerGen: 0, serverGen: 0 }, end);
      };
      FeatureCollectionPBuffer.ServerGens._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.minServerGen = pbf.readVarint();
          else if (tag === 2)
              obj.serverGen = pbf.readVarint();
      };
      FeatureCollectionPBuffer.ServerGens.write = function (obj, pbf) {
          if (obj.minServerGen)
              pbf.writeVarintField(1, obj.minServerGen);
          if (obj.serverGen)
              pbf.writeVarintField(2, obj.serverGen);
      };
      // FeatureCollectionPBuffer.Scale ========================================
      FeatureCollectionPBuffer.Scale = {};
      FeatureCollectionPBuffer.Scale.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Scale._readField, { xScale: 0, yScale: 0, mScale: 0, zScale: 0 }, end);
      };
      FeatureCollectionPBuffer.Scale._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.xScale = pbf.readDouble();
          else if (tag === 2)
              obj.yScale = pbf.readDouble();
          else if (tag === 3)
              obj.mScale = pbf.readDouble();
          else if (tag === 4)
              obj.zScale = pbf.readDouble();
      };
      FeatureCollectionPBuffer.Scale.write = function (obj, pbf) {
          if (obj.xScale)
              pbf.writeDoubleField(1, obj.xScale);
          if (obj.yScale)
              pbf.writeDoubleField(2, obj.yScale);
          if (obj.mScale)
              pbf.writeDoubleField(3, obj.mScale);
          if (obj.zScale)
              pbf.writeDoubleField(4, obj.zScale);
      };
      // FeatureCollectionPBuffer.Translate ========================================
      FeatureCollectionPBuffer.Translate = {};
      FeatureCollectionPBuffer.Translate.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Translate._readField, { xTranslate: 0, yTranslate: 0, mTranslate: 0, zTranslate: 0 }, end);
      };
      FeatureCollectionPBuffer.Translate._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.xTranslate = pbf.readDouble();
          else if (tag === 2)
              obj.yTranslate = pbf.readDouble();
          else if (tag === 3)
              obj.mTranslate = pbf.readDouble();
          else if (tag === 4)
              obj.zTranslate = pbf.readDouble();
      };
      FeatureCollectionPBuffer.Translate.write = function (obj, pbf) {
          if (obj.xTranslate)
              pbf.writeDoubleField(1, obj.xTranslate);
          if (obj.yTranslate)
              pbf.writeDoubleField(2, obj.yTranslate);
          if (obj.mTranslate)
              pbf.writeDoubleField(3, obj.mTranslate);
          if (obj.zTranslate)
              pbf.writeDoubleField(4, obj.zTranslate);
      };
      // FeatureCollectionPBuffer.Transform ========================================
      FeatureCollectionPBuffer.Transform = {};
      FeatureCollectionPBuffer.Transform.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.Transform._readField, { quantizeOriginPostion: 0, scale: null, translate: null }, end);
      };
      FeatureCollectionPBuffer.Transform._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.quantizeOriginPostion = pbf.readVarint();
          else if (tag === 2)
              obj.scale = FeatureCollectionPBuffer.Scale.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 3)
              obj.translate = FeatureCollectionPBuffer.Translate.read(pbf, pbf.readVarint() + pbf.pos);
      };
      FeatureCollectionPBuffer.Transform.write = function (obj, pbf) {
          if (obj.quantizeOriginPostion)
              pbf.writeVarintField(1, obj.quantizeOriginPostion);
          if (obj.scale)
              pbf.writeMessage(2, FeatureCollectionPBuffer.Scale.write, obj.scale);
          if (obj.translate)
              pbf.writeMessage(3, FeatureCollectionPBuffer.Translate.write, obj.translate);
      };
      // FeatureCollectionPBuffer.FeatureResult ========================================
      FeatureCollectionPBuffer.FeatureResult = {};
      FeatureCollectionPBuffer.FeatureResult.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.FeatureResult._readField, { objectIdFieldName: "", uniqueIdField: null, globalIdFieldName: "", geohashFieldName: "", geometryProperties: null, serverGens: null, geometryType: 0, spatialReference: null, exceededTransferLimit: false, hasZ: false, hasM: false, transform: null, fields: [], values: [], features: [] }, end);
      };
      FeatureCollectionPBuffer.FeatureResult._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.objectIdFieldName = pbf.readString();
          else if (tag === 2)
              obj.uniqueIdField = FeatureCollectionPBuffer.UniqueIdField.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 3)
              obj.globalIdFieldName = pbf.readString();
          else if (tag === 4)
              obj.geohashFieldName = pbf.readString();
          else if (tag === 5)
              obj.geometryProperties = FeatureCollectionPBuffer.GeometryProperties.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 6)
              obj.serverGens = FeatureCollectionPBuffer.ServerGens.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 7)
              obj.geometryType = pbf.readVarint();
          else if (tag === 8)
              obj.spatialReference = FeatureCollectionPBuffer.SpatialReference.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 9)
              obj.exceededTransferLimit = pbf.readBoolean();
          else if (tag === 10)
              obj.hasZ = pbf.readBoolean();
          else if (tag === 11)
              obj.hasM = pbf.readBoolean();
          else if (tag === 12)
              obj.transform = FeatureCollectionPBuffer.Transform.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 13)
              obj.fields.push(FeatureCollectionPBuffer.Field.read(pbf, pbf.readVarint() + pbf.pos));
          else if (tag === 14)
              obj.values.push(FeatureCollectionPBuffer.Value.read(pbf, pbf.readVarint() + pbf.pos));
          else if (tag === 15)
              obj.features.push(FeatureCollectionPBuffer.Feature.read(pbf, pbf.readVarint() + pbf.pos));
      };
      FeatureCollectionPBuffer.FeatureResult.write = function (obj, pbf) {
          if (obj.objectIdFieldName)
              pbf.writeStringField(1, obj.objectIdFieldName);
          if (obj.uniqueIdField)
              pbf.writeMessage(2, FeatureCollectionPBuffer.UniqueIdField.write, obj.uniqueIdField);
          if (obj.globalIdFieldName)
              pbf.writeStringField(3, obj.globalIdFieldName);
          if (obj.geohashFieldName)
              pbf.writeStringField(4, obj.geohashFieldName);
          if (obj.geometryProperties)
              pbf.writeMessage(5, FeatureCollectionPBuffer.GeometryProperties.write, obj.geometryProperties);
          if (obj.serverGens)
              pbf.writeMessage(6, FeatureCollectionPBuffer.ServerGens.write, obj.serverGens);
          if (obj.geometryType)
              pbf.writeVarintField(7, obj.geometryType);
          if (obj.spatialReference)
              pbf.writeMessage(8, FeatureCollectionPBuffer.SpatialReference.write, obj.spatialReference);
          if (obj.exceededTransferLimit)
              pbf.writeBooleanField(9, obj.exceededTransferLimit);
          if (obj.hasZ)
              pbf.writeBooleanField(10, obj.hasZ);
          if (obj.hasM)
              pbf.writeBooleanField(11, obj.hasM);
          if (obj.transform)
              pbf.writeMessage(12, FeatureCollectionPBuffer.Transform.write, obj.transform);
          if (obj.fields)
              for (var i = 0; i < obj.fields.length; i++)
                  pbf.writeMessage(13, FeatureCollectionPBuffer.Field.write, obj.fields[i]);
          if (obj.values)
              for (i = 0; i < obj.values.length; i++)
                  pbf.writeMessage(14, FeatureCollectionPBuffer.Value.write, obj.values[i]);
          if (obj.features)
              for (i = 0; i < obj.features.length; i++)
                  pbf.writeMessage(15, FeatureCollectionPBuffer.Feature.write, obj.features[i]);
      };
      // FeatureCollectionPBuffer.CountResult ========================================
      FeatureCollectionPBuffer.CountResult = {};
      FeatureCollectionPBuffer.CountResult.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.CountResult._readField, { count: 0 }, end);
      };
      FeatureCollectionPBuffer.CountResult._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.count = pbf.readVarint();
      };
      FeatureCollectionPBuffer.CountResult.write = function (obj, pbf) {
          if (obj.count)
              pbf.writeVarintField(1, obj.count);
      };
      // FeatureCollectionPBuffer.ObjectIdsResult ========================================
      FeatureCollectionPBuffer.ObjectIdsResult = {};
      FeatureCollectionPBuffer.ObjectIdsResult.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.ObjectIdsResult._readField, { objectIdFieldName: "", serverGens: null, objectIds: [] }, end);
      };
      FeatureCollectionPBuffer.ObjectIdsResult._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.objectIdFieldName = pbf.readString();
          else if (tag === 2)
              obj.serverGens = FeatureCollectionPBuffer.ServerGens.read(pbf, pbf.readVarint() + pbf.pos);
          else if (tag === 3)
              pbf.readPackedVarint(obj.objectIds);
      };
      FeatureCollectionPBuffer.ObjectIdsResult.write = function (obj, pbf) {
          if (obj.objectIdFieldName)
              pbf.writeStringField(1, obj.objectIdFieldName);
          if (obj.serverGens)
              pbf.writeMessage(2, FeatureCollectionPBuffer.ServerGens.write, obj.serverGens);
          if (obj.objectIds)
              pbf.writePackedVarint(3, obj.objectIds);
      };
      // FeatureCollectionPBuffer.QueryResult ========================================
      FeatureCollectionPBuffer.QueryResult = {};
      FeatureCollectionPBuffer.QueryResult.read = function (pbf, end) {
          return pbf.readFields(FeatureCollectionPBuffer.QueryResult._readField, { featureResult: null, Results: null, countResult: null, idsResult: null }, end);
      };
      FeatureCollectionPBuffer.QueryResult._readField = function (tag, obj, pbf) {
          if (tag === 1)
              obj.featureResult = FeatureCollectionPBuffer.FeatureResult.read(pbf, pbf.readVarint() + pbf.pos), obj.Results = "featureResult";
          else if (tag === 2)
              obj.countResult = FeatureCollectionPBuffer.CountResult.read(pbf, pbf.readVarint() + pbf.pos), obj.Results = "countResult";
          else if (tag === 3)
              obj.idsResult = FeatureCollectionPBuffer.ObjectIdsResult.read(pbf, pbf.readVarint() + pbf.pos), obj.Results = "idsResult";
      };
      FeatureCollectionPBuffer.QueryResult.write = function (obj, pbf) {
          if (obj.featureResult)
              pbf.writeMessage(1, FeatureCollectionPBuffer.FeatureResult.write, obj.featureResult);
          if (obj.countResult)
              pbf.writeMessage(2, FeatureCollectionPBuffer.CountResult.write, obj.countResult);
          if (obj.idsResult)
              pbf.writeMessage(3, FeatureCollectionPBuffer.ObjectIdsResult.write, obj.idsResult);
      };
      return FeatureCollectionPBuffer;
  }
  ;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getDefaultExportFromNamespaceIfPresent (n) {
  	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
  }

  function getDefaultExportFromNamespaceIfNotNamed (n) {
  	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
  }

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			if (this instanceof a) {
  				var args = [null];
  				args.push.apply(args, arguments);
  				var Ctor = Function.bind.apply(f, args);
  				return new Ctor();
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var ieee754$1 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  var read = ieee754$1.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  };

  var write = ieee754$1.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = ((value * c) - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  'use strict';

  var pbf = Pbf;

  var ieee754 = ieee754$1;

  function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
  }

  Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
  Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
  Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
  Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

  var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
      SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

  // Threshold chosen based on both benchmarking and knowledge about browser string
  // data structures (which currently switch structure types at 12 bytes or more)
  var TEXT_DECODER_MIN_LENGTH = 12;
  var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

  Pbf.prototype = {

      destroy: function() {
          this.buf = null;
      },

      // === READING =================================================================

      readFields: function(readField, result, end) {
          end = end || this.length;

          while (this.pos < end) {
              var val = this.readVarint(),
                  tag = val >> 3,
                  startPos = this.pos;

              this.type = val & 0x7;
              readField(tag, result, this);

              if (this.pos === startPos) this.skip(val);
          }
          return result;
      },

      readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
      },

      readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
      },

      readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
      },

      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

      readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
      },

      readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
      },

      readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
      },

      readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
      },

      readVarint: function(isSigned) {
          var buf = this.buf,
              val, b;

          b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
          b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
          b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
          b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
          b = buf[this.pos];   val |= (b & 0x0f) << 28;

          return readVarintRemainder(val, isSigned, this);
      },

      readVarint64: function() { // for compatibility with v2.0.1
          return this.readVarint(true);
      },

      readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
      },

      readBoolean: function() {
          return Boolean(this.readVarint());
      },

      readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;

          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
              // longer strings are fast with the built-in browser TextDecoder API
              return readUtf8TextDecoder(this.buf, pos, end);
          }
          // short strings are fast with our custom implementation
          return readUtf8(this.buf, pos, end);
      },

      readBytes: function() {
          var end = this.readVarint() + this.pos,
              buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
      },

      // verbose for performance reasons; doesn't affect gzipped size

      readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readVarint(isSigned));
          return arr;
      },
      readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readSVarint());
          return arr;
      },
      readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readBoolean());
          return arr;
      },
      readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readFloat());
          return arr;
      },
      readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readDouble());
          return arr;
      },
      readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readFixed32());
          return arr;
      },
      readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readSFixed32());
          return arr;
      },
      readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readFixed64());
          return arr;
      },
      readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end) arr.push(this.readSFixed64());
          return arr;
      },

      skip: function(val) {
          var type = val & 0x7;
          if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
          else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32) this.pos += 4;
          else if (type === Pbf.Fixed64) this.pos += 8;
          else throw new Error('Unimplemented type: ' + type);
      },

      // === WRITING =================================================================

      writeTag: function(tag, type) {
          this.writeVarint((tag << 3) | type);
      },

      realloc: function(min) {
          var length = this.length || 16;

          while (length < this.pos + min) length *= 2;

          if (length !== this.length) {
              var buf = new Uint8Array(length);
              buf.set(this.buf);
              this.buf = buf;
              this.length = length;
          }
      },

      finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
      },

      writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
      },

      writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
      },

      writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
      },

      writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
      },

      writeVarint: function(val) {
          val = +val || 0;

          if (val > 0xfffffff || val < 0) {
              writeBigVarint(val, this);
              return;
          }

          this.realloc(4);

          this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
          this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
          this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
          this.buf[this.pos++] =   (val >>> 7) & 0x7f;
      },

      writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },

      writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
      },

      writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);

          this.pos++; // reserve 1 byte for short string length

          var startPos = this.pos;
          // write the string directly to the buffer and see how much was written
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;

          if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

          // finally, write the message length in the reserved place and restore the position
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
      },

      writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
      },

      writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
      },

      writeBytes: function(buffer) {
          var len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
      },

      writeRawMessage: function(fn, obj) {
          this.pos++; // reserve 1 byte for short message length

          // write the message directly to the buffer and see how much was written
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;

          if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

          // finally, write the message length in the reserved place and restore the position
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
      },

      writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
      },

      writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },
      writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },
      writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },
      writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },
      writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },
      writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },
      writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },
      writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },
      writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },

      writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
      },
      writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
      },
      writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
      }
  };

  function readVarintRemainder(l, s, p) {
      var buf = p.buf,
          h, b;

      b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
      b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
      b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
      b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
      b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
      b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

      throw new Error('Expected varint not more than 10 bytes');
  }

  function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ?
          pbf.readVarint() + pbf.pos : pbf.pos + 1;
  }

  function toNum(low, high, isSigned) {
      if (isSigned) {
          return high * 0x100000000 + (low >>> 0);
      }

      return ((high >>> 0) * 0x100000000) + (low >>> 0);
  }

  function writeBigVarint(val, pbf) {
      var low, high;

      if (val >= 0) {
          low  = (val % 0x100000000) | 0;
          high = (val / 0x100000000) | 0;
      } else {
          low  = ~(-val % 0x100000000);
          high = ~(-val / 0x100000000);

          if (low ^ 0xffffffff) {
              low = (low + 1) | 0;
          } else {
              low = 0;
              high = (high + 1) | 0;
          }
      }

      if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
          throw new Error('Given varint doesn\'t fit into 10 bytes');
      }

      pbf.realloc(10);

      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
  }

  function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
      pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
      pbf.buf[pbf.pos]   = low & 0x7f;
  }

  function writeBigVarintHigh(high, pbf) {
      var lsb = (high & 0x07) << 4;

      pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
      pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
      pbf.buf[pbf.pos++]  = high & 0x7f;
  }

  function makeRoomForExtraLength(startPos, len, pbf) {
      var extraLen =
          len <= 0x3fff ? 1 :
          len <= 0x1fffff ? 2 :
          len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

      // if 1 byte isn't enough for encoding message length, shift the data to the right
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
  }

  function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
  function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
  function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
  function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
  function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
  function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
  function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
  function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
  function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

  // Buffer code below from https://github.com/feross/buffer, MIT-licensed

  function readUInt32(buf, pos) {
      return ((buf[pos]) |
          (buf[pos + 1] << 8) |
          (buf[pos + 2] << 16)) +
          (buf[pos + 3] * 0x1000000);
  }

  function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = (val >>> 8);
      buf[pos + 2] = (val >>> 16);
      buf[pos + 3] = (val >>> 24);
  }

  function readInt32(buf, pos) {
      return ((buf[pos]) |
          (buf[pos + 1] << 8) |
          (buf[pos + 2] << 16)) +
          (buf[pos + 3] << 24);
  }

  function readUtf8(buf, pos, end) {
      var str = '';
      var i = pos;

      while (i < end) {
          var b0 = buf[i];
          var c = null; // codepoint
          var bytesPerSequence =
              b0 > 0xEF ? 4 :
              b0 > 0xDF ? 3 :
              b0 > 0xBF ? 2 : 1;

          if (i + bytesPerSequence > end) break;

          var b1, b2, b3;

          if (bytesPerSequence === 1) {
              if (b0 < 0x80) {
                  c = b0;
              }
          } else if (bytesPerSequence === 2) {
              b1 = buf[i + 1];
              if ((b1 & 0xC0) === 0x80) {
                  c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                  if (c <= 0x7F) {
                      c = null;
                  }
              }
          } else if (bytesPerSequence === 3) {
              b1 = buf[i + 1];
              b2 = buf[i + 2];
              if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                  c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                  if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                      c = null;
                  }
              }
          } else if (bytesPerSequence === 4) {
              b1 = buf[i + 1];
              b2 = buf[i + 2];
              b3 = buf[i + 3];
              if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                  c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                  if (c <= 0xFFFF || c >= 0x110000) {
                      c = null;
                  }
              }
          }

          if (c === null) {
              c = 0xFFFD;
              bytesPerSequence = 1;

          } else if (c > 0xFFFF) {
              c -= 0x10000;
              str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
              c = 0xDC00 | c & 0x3FF;
          }

          str += String.fromCharCode(c);
          i += bytesPerSequence;
      }

      return str;
  }

  function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
  }

  function writeUtf8(buf, str, pos) {
      for (var i = 0, c, lead; i < str.length; i++) {
          c = str.charCodeAt(i); // code point

          if (c > 0xD7FF && c < 0xE000) {
              if (lead) {
                  if (c < 0xDC00) {
                      buf[pos++] = 0xEF;
                      buf[pos++] = 0xBF;
                      buf[pos++] = 0xBD;
                      lead = c;
                      continue;
                  } else {
                      c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                      lead = null;
                  }
              } else {
                  if (c > 0xDBFF || (i + 1 === str.length)) {
                      buf[pos++] = 0xEF;
                      buf[pos++] = 0xBF;
                      buf[pos++] = 0xBD;
                  } else {
                      lead = c;
                  }
                  continue;
              }
          } else if (lead) {
              buf[pos++] = 0xEF;
              buf[pos++] = 0xBF;
              buf[pos++] = 0xBD;
              lead = null;
          }

          if (c < 0x80) {
              buf[pos++] = c;
          } else {
              if (c < 0x800) {
                  buf[pos++] = c >> 0x6 | 0xC0;
              } else {
                  if (c < 0x10000) {
                      buf[pos++] = c >> 0xC | 0xE0;
                  } else {
                      buf[pos++] = c >> 0x12 | 0xF0;
                      buf[pos++] = c >> 0xC & 0x3F | 0x80;
                  }
                  buf[pos++] = c >> 0x6 & 0x3F | 0x80;
              }
              buf[pos++] = c & 0x3F | 0x80;
          }
      }
      return pos;
  }

  ;
  ;
  //type ArcgisRestSourceSpecification = any;
  var esriPbfGeometryTypeEnum;
  (function (esriPbfGeometryTypeEnum) {
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypePoint"] = 0] = "esriGeometryTypePoint";
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypeMultipoint"] = 1] = "esriGeometryTypeMultipoint";
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypePolyline"] = 2] = "esriGeometryTypePolyline";
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypePolygon"] = 3] = "esriGeometryTypePolygon";
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypeMultipatch"] = 4] = "esriGeometryTypeMultipatch";
      esriPbfGeometryTypeEnum[esriPbfGeometryTypeEnum["esriGeometryTypeNone"] = 127] = "esriGeometryTypeNone";
  })(esriPbfGeometryTypeEnum || (esriPbfGeometryTypeEnum = {}));
  ;

  class ConvertPbf {
      constructor(pbfData) {
          this.data = pbfData;
      }
      async convert() {
          var _a;
          const pbf$1 = new pbf(this.data);
          const pbfJson = proto().read(pbf$1);
          // Get the FeatureResult
          if (pbfJson.queryResult === null) {
              //console.warn('issue with the result', pbfJson);
              return this._buildResponse({
                  'exceededTransferLimit': true,
              }, []);
          }
          const featureResult = pbfJson.queryResult.featureResult;
          // Get the field names
          const fields = featureResult.fields.map((field) => field.name);
          // Get the translation info
          const translation = featureResult.transform.translate;
          const scale = featureResult.transform.scale;
          const geometryType = featureResult.geometryType;
          const quantizeOriginPostion = featureResult.transform.quantizeOriginPostion;
          const srid = (_a = featureResult.spatialReference) === null || _a === void 0 ? void 0 : _a.wkid.toString();
          const features = featureResult.features.map((feature) => {
              // Parse each attribute
              let attributes = feature.attributes
                  .map((attribute, index) => ({ 'key': fields[index], 'value': attribute[attribute['value_type']] }))
                  .reduce((a, c) => {
                  const newObj = {};
                  newObj[c.key] = c.value;
                  return { ...a, ...newObj };
              }, {});
              // Parse the geometries and clean up the quantization
              let rings = [[[]]];
              if ((feature.geometry !== null)) {
                  let counts = geometryType === esriPbfGeometryTypeEnum.esriGeometryTypePoint ? [1] : (feature.geometry.lengths);
                  // Break into X and Y rings
                  let x = [];
                  let y = [];
                  feature.geometry.coords.forEach((coord, idx) => {
                      if (idx % 2 === 0) {
                          x.push(coord);
                      }
                      else {
                          y.push(coord);
                      }
                  });
                  //let x = feature.geometry.coords.filter((_: number, idx: number) => idx % 2 === 0);
                  //let y = feature.geometry.coords.filter((_: number, idx: number) => idx % 2 === 1);
                  // dezigzag the rings, and merge + reproject them
                  let ringsX = deZigZag(x, counts, scale.xScale, translation.xTranslate, false);
                  let ringsY = deZigZag(y, counts, scale.yScale, translation.yTranslate, quantizeOriginPostion === 0);
                  // Merge the rings
                  rings = mergeRings(ringsX, ringsY, srid);
                  //rings = ringsX.map((ring, i) => ring.map((x, j) => [x, ringsY[i][j]]));
              }
              let geometry = {};
              if (esriPbfGeometryTypeEnum[geometryType] === 'esriGeometryTypePoint') {
                  geometry = { 'x': rings[0][0][0], 'y': rings[0][0][1] };
              }
              else if (esriPbfGeometryTypeEnum[geometryType] === 'esriGeometryTypeMultiPoint') {
                  geometry = { 'points': rings[0] };
              }
              else if (esriPbfGeometryTypeEnum[geometryType] === 'esriGeometryTypePolyline') {
                  geometry = { paths: rings };
              }
              else if (esriPbfGeometryTypeEnum[geometryType] === 'esriGeometryTypePolygon') {
                  geometry = { rings: rings };
              }
              return {
                  'geometry': geometry,
                  'attributes': attributes,
              };
          });
          return this._buildResponse(featureResult, features);
      }
      _buildResponse(featureResult, features) {
          return {
              'features': features,
              'exceededTransferLimit': featureResult.exceededTransferLimit,
              'spatialReference': { 'wkid': 4326, 'latestWkid': 4326 },
              'geometryType': esriPbfGeometryTypeEnum[featureResult.geometryType || 127].replace('Type', ''),
              'hasM': featureResult.hasM,
              'hasZ': featureResult.hasZ,
              'globalIdFieldName': featureResult.globalIdFieldName
          };
      }
  }
  ;

  class GeometriesAtZoom {
      constructor() {
          // Keeps track of the geometries that have already been loaded
          this._geometriesAtZoom = new Array(24);
          this._maxGeometryZoom = 0;
      }
      async getKeysAtZoom(zoom, maxZoom) {
          // Determine the max zoom based on the user input, the map's maxzoom, or the maxzoom we have cached
          maxZoom = maxZoom !== undefined ? maxZoom : this._maxGeometryZoom;
          const geometryGroups = [];
          for (let z = (Math.min(maxZoom, this._maxGeometryZoom)); z >= zoom; z--) {
              if (this._geometriesAtZoom[z] !== undefined) {
                  geometryGroups.push([...this._geometriesAtZoom[z].keys()]);
              }
          }
          return geometryGroups.flat();
      }
      updateKeyAtZoom(zoom, primaryKey) {
          let returnValue = 'added';
          if (this._geometriesAtZoom[zoom] === undefined)
              this._geometriesAtZoom[zoom] = new Map();
          this._maxGeometryZoom = Math.max(this._maxGeometryZoom, zoom);
          for (let z = 0; z < zoom; z++) {
              if (this._geometriesAtZoom[z] !== undefined) {
                  this._geometriesAtZoom[z].delete(primaryKey);
                  returnValue = 'updated';
              }
          }
          this._geometriesAtZoom[zoom].set(primaryKey, true);
          return returnValue;
      }
      async updateKeysAtZoom(zoom, primaryKeys) {
          return primaryKeys.map(primaryKey => this.updateKeyAtZoom(zoom, primaryKey));
      }
  }

  const libraries = {
      'ConvertPbf': ConvertPbf,
      'GeometriesAtZoom': GeometriesAtZoom,
      'DeZigZagJSON': DeZigZagJSON
  };
  const subClasses = Object.keys(libraries);
  let subClass;
  self.addEventListener('message', e => {
      const data = (e.data || e);
      const post = (id, err, res, type) => {
          postMessage({
              type: type ? type : (err ? 'error' : 'response'),
              id: id,
              message: res,
              error: err
          });
      };
      const commands = {
          'init': (msg) => {
              const { id, command, message } = msg;
              subClass = new libraries[command](...message);
              // return the class' methods
              const fns = [
                  ...Object.getOwnPropertyNames(libraries[command].prototype),
                  ...Object.keys(subClass)
              ].map(key => [key, typeof libraries[command].prototype[key]])
                  .reduce((a, c) => ({ ...a, ...{ [c[0]]: c[1] } }), {});
              post(id, undefined, fns, 'init_response');
          },
          'get': function (msg) {
              const { id, command } = msg;
              if (subClass && subClass[command]) {
                  post(id, undefined, subClass[command]);
              }
              else {
                  post(id, undefined, undefined);
              }
          },
          'exec': function (msg) {
              const { id, command, message } = msg;
              if (subClass && subClass[command] && typeof subClass[command] === 'function') {
                  const cmd = subClass[command]
                      .apply(subClass, message);
                  if (!!cmd && typeof cmd.then === 'function') {
                      // It's a promise, so wait for it
                      cmd
                          .then(res => post(id, undefined, res))
                          .catch(e => post(id, e));
                  }
                  else {
                      // Not a promise, just return it
                      post(id, undefined, cmd);
                  }
              }
              else {
                  // Error
                  post(id, new Error(`command "${command}" not found`));
              }
          }
      };
      if (commands[data.type]) {
          commands[data.type](data);
      }
  });

  const rnd = () => Math.random().toString(36).substring(2);
  function supportsWorkers() {
      let supported = false;
      try {
          supported = typeof (window.Worker) === 'function';
      }
      catch (e) {
          supported = false;
      }
      return supported;
  }
  ;
  function createActor(subClass, args = []) {
      if (supportsWorkers()) {
          //throw new Error('WebWorker Not Supported');
          return new Actor(subClass, args);
      }
      else {
          return new WorkerlessActor(subClass, args);
      }
  }
  ;
  class Actor {
      constructor(subClass, args = []) {
          this.initId = rnd() + '-' + subClass;
          this.worker = new WorkerFactory();
          this.handlers = new Map();
          // Listen for any messages back from the worker
          this.worker.onmessage = (event) => {
              const data = event.data;
              const handler = this.handlers.get(data.id);
              const that = this;
              if (handler) {
                  if (data.type === 'response') {
                      handler.res(data.message);
                  }
                  if (data.type === 'error') {
                      const error = data.error || new Error(`Unknown error with ${this.subClass}`);
                      handler.rej(error);
                  }
                  if (data.type === 'init_response') {
                      this._ = Object.keys(data.message)
                          .map(key => {
                          const isFn = typeof data.message[key];
                          const subFunction = function () {
                              return isFn ?
                                  that.exec(key)(...arguments) :
                                  that.get(key);
                          };
                          return [key, subFunction];
                      })
                          .reduce((a, c) => ({ ...a, ...{ [c[0]]: c[1] } }), {});
                      handler.res(this._);
                  }
              }
          };
          // Tell the worker to create the class
          this.worker.postMessage({
              type: 'init',
              id: this.initId,
              command: subClass,
              message: args
          });
      }
      onLoad() {
          return new Promise((res) => {
              (this._ === undefined) ?
                  this.handlers.set(this.initId, { 'res': res, 'rej': res }) :
                  res(this._);
          });
      }
      exec(command) {
          const that = this;
          return function (...args) {
              return new Promise((res, rej) => {
                  const id = rnd() + '-' + command;
                  that.handlers.set(id, { 'res': res, 'rej': rej });
                  // Tell the worker to run the command
                  that.worker.postMessage({
                      type: 'exec',
                      id: id,
                      command: command,
                      message: [...args]
                  });
              });
          };
      }
      get(command) {
          return new Promise((res, rej) => {
              const id = rnd() + '-' + command;
              this.handlers.set(id, { 'res': res, 'rej': rej });
              // Tell the worker to run the command
              this.worker.postMessage({
                  type: 'get',
                  id: id,
                  command: command,
                  message: []
              });
          });
      }
  }
  ;
  /** Mimic the Actor so we can use the same interface when WebWorkers are not supported */
  class WorkerlessActor {
      constructor(subClass, args = []) {
          this.subClass = new libraries[subClass](...args);
      }
      onLoad() {
          return new Promise(res => res(this));
      }
      get(command) {
          return new Promise((res) => res(this.subClass[command]));
      }
      exec(command) {
          const that = this;
          return function (...args) {
              return Promise.resolve(that.subClass[command](...args));
          };
      }
  }

  class MapFetch {
      constructor(map) {
          this._map = map;
      }
      async fetch(url, init = {}, callbackCancel) {
          let urlString = url.toString();
          // URLs over 2048 characters can't use GET, so if no method is set, switch them to POST
          // Convert the body to a query string
          // TODO if there is already a querystring, we can't just append it
          // TODO this only works with urlencoded bodies, there can be others?
          const getUrl = init.body ? (urlString.replace(/\??$/, '?') + init.body) : urlString;
          if (getUrl.length > 2048 && init.method === undefined) {
              init.method = 'POST';
          }
          // Default to GET
          init.method = ['POST', 'GET', 'PUT'].indexOf((init.method || '').toUpperCase()) > -1 ? (init.method || '').toUpperCase() : 'GET';
          if (init.method === 'GET') {
              // We can't use the body, so we need to make it into a queryString
              urlString = getUrl;
          }
          const requestParameters = {
              url: urlString,
              method: init.method
          };
          if (init.method === 'POST') {
              if (init.headers)
                  requestParameters.headers = init.headers;
              if (init.body)
                  requestParameters.body = init.body.toString();
          }
          return ({
              arrayBuffer: async () => {
                  requestParameters.type = 'arrayBuffer';
                  return this._getResource(requestParameters, callbackCancel);
              },
              json: async () => {
                  requestParameters.type = 'json';
                  return this._getResource(requestParameters, callbackCancel);
              },
              text: async () => {
                  requestParameters.type = 'string';
                  return this._getResource(requestParameters, callbackCancel);
              }
          });
      }
      async _getResource(requestParameters, callbackCancel) {
          return new Promise((res, rej) => {
              let cancelable = this._map.style.getResource(Math.random().toString(32).substring(2), requestParameters, (e, r) => {
                  if (e) {
                      rej(e.toString());
                  }
                  else {
                      res(r);
                  }
                  ;
              });
              if (callbackCancel) {
                  callbackCancel({
                      'cancel': () => {
                          cancelable.cancel();
                          rej('cancel');
                      }
                  });
              }
          });
      }
  }

  const ArcGisRestSourceDefaults = {
      where: '1=1',
      outfields: '*',
      resultRecordCount: undefined,
  };
  function ArcGisRestSource(mapLibrary) {
      return class ArcGisRest extends mapLibrary['GeoJSONSource'] {
          constructor(id, originalSource, dispatcher, eventedParent) {
              super(id, { 'type': 'geojson', collectResourceTiming: false }, dispatcher, eventedParent);
              this._quantizedQuery = false;
              this._requestFormat = 'json';
              this._geometriesAtZoom = createActor('GeometriesAtZoom');
              this._requests = [];
              this._sortableFields = [];
              this._events = new mapLibrary['Evented'];
              this._liveLayer = false;
              this._waitTimes = {};
              // Set the defaults
              this.id = id;
              this._originalSource = { ...ArcGisRestSourceDefaults, ...originalSource };
              // Clean the input URL to remove trailing query strings
              const cleanedUrl = this._originalSource.url.match(/.+?[Feature|Map]Server\/\d{1,}/);
              if (cleanedUrl) {
                  this._originalSource.url = cleanedUrl[0];
              }
              else {
                  throw new Error('ArcGisRest URL is invalid ' + this._originalSource.url);
              }
              window.source = this;
          }
          onAdd(map) {
              this.map = map;
              this._asyncLoad(map).then(() => super.load());
          }
          async _asyncLoad(map) {
              // Read the config from the server
              const url = new URL(this._originalSource.url);
              url.searchParams.append('f', 'json');
              if (this._originalSource.token) {
                  url.searchParams.append('token', this._originalSource.token);
              }
              // Use the built in fetch, and make it cancellable
              const mapFetch = new MapFetch(map);
              const esriLayerConfig = await (await mapFetch.fetch(url)).json();
              if (esriLayerConfig.error) {
                  console.error('ArcGIS Error', esriLayerConfig.error);
                  return false;
              }
              // Get some important values from this
              const maxRecordCount = esriLayerConfig.maxRecordCount || 500;
              const supportedQueryFormats = (esriLayerConfig.supportedQueryFormats || "")
                  .toLowerCase()
                  .replace(/\s/g, '')
                  .split(',');
              const supportsPbf = supportedQueryFormats.indexOf('pbf') > -1;
              this._requestFormat = supportsPbf ? 'pbf' : 'json';
              // Only quantize lines and polygons
              this._quantizedQuery = (esriLayerConfig.supportsCoordinatesQuantization === true) && (esriLayerConfig.geometryType === 'esriGeometryPolygon' ||
                  esriLayerConfig.geometryType === 'esriGeometryPolyline');
              if (esriLayerConfig.fields) {
                  this._sortableFields = (esriLayerConfig.fields)
                      .filter(field => ([
                      'esriFieldTypeString', 'esriFieldTypeDouble', 'esriFieldTypeDate', 'esriFieldTypeGUID',
                      'esriFieldTypeGlobalID', 'esriFieldTypeInteger', 'esriFieldTypeOID', 'esriFieldTypeSingle',
                      'esriFieldTypeSmallInteger'
                  ].indexOf(field.type) > -1) &&
                      field.name.indexOf('()') === -1 &&
                      (field.alias || '').indexOf('()') === -1)
                      .map(field => field.name);
              }
              if (esriLayerConfig.indexes) {
                  this.promoteId = esriLayerConfig.indexes
                      .filter((index) => (index.isUnique === true) &&
                      index.fields &&
                      this._sortableFields.indexOf(index.fields) > -1)
                      .map((index) => index['fields'])[0];
              }
              if (esriLayerConfig.fields) {
                  this._primaryKeyType = esriLayerConfig.fields
                      .filter((f) => f.name === this.promoteId)
                      .map((f) => [
                      'esriFieldTypeDouble', 'esriFieldTypeDate', 'esriFieldTypeGUID',
                      'esriFieldTypeGlobalID', 'esriFieldTypeInteger', 'esriFieldTypeOID', 'esriFieldTypeSingle',
                      'esriFieldTypeSmallInteger'
                  ].indexOf(f.type) > -1 ? 'number' : 'string')[0];
              }
              // Set the record count to the smaller of the two values (either the server max record count, or the defined one)
              this._originalSource.resultRecordCount = (this._originalSource.resultRecordCount || Infinity) < maxRecordCount ? this._originalSource.resultRecordCount : maxRecordCount;
              // Start with blank data
              this.setData({
                  "type": "FeatureCollection",
                  "features": []
              });
              this._events.on('data', (esriData) => this.drawMapData(esriData.json, esriData.zoom));
              this.loadMapData(map);
              // Don't load the map if we're not trying to request one (liveLayer)
              map.on('moveend', () => this._liveLayer && this._waitEvent('redrawMap', 100));
              this._events.on('redrawMap', () => this.loadMapData(map));
          }
          ;
          loadTile(tile, callback) {
              if (!this._liveLayer) {
                  this._liveLayer = true; // This makes sure we're only loading the layer if its tiles are requested
                  this._waitEvent('redrawMap', 1000);
              }
              super.loadTile(tile, callback);
          }
          async loadMapData(map, bounds) {
              map = map === undefined ? this.map : map;
              if (map === undefined)
                  throw new Error('Source Data (Source ID: ' + this.id + ') could not be loaded');
              console.log('LOADING');
              // Don't load the map if we're not trying to request one (liveLayer)
              //if (!this._liveLayer) return;
              // Get list of all geometries at this or a higher zoom, if it doesn't support quantization, set to max zoom
              const displayZoom = this._quantizedQuery ? Math.floor(this.map.getZoom()) : this.map.getMaxZoom();
              // Create the ArcGIS Request
              let where = this._originalSource.where;
              // Build the request object
              const request = {
                  where
              };
              // If there is a primary key, make sure we don't download it again
              if (this.promoteId) {
                  bounds = bounds || [map.getBounds().getWest(), map.getBounds().getSouth(), map.getBounds().getEast(), map.getBounds().getNorth()];
                  const projectedSouthWest = fromWGS84(bounds[0], bounds[1]);
                  const projectedNorthEast = fromWGS84(bounds[2], bounds[3]);
                  const projectedBounds = [projectedSouthWest.x, projectedSouthWest.y, projectedNorthEast.x, projectedNorthEast.y];
                  const alreadyLoadedKeys = await this._geometriesAtZoom.exec('getKeysAtZoom')(displayZoom);
                  request.geometry = projectedBounds.join(',');
                  request.geometryType = 'esriGeometryEnvelope';
                  request.inSR = '3857';
                  const wrap = (v) => this._primaryKeyType === 'string' ? `'${v}'` : v;
                  if (alreadyLoadedKeys.length) {
                      request.where = `(${where}) AND "${this.promoteId}" NOT IN (${alreadyLoadedKeys.map(k => wrap(k)).join(',')})`;
                  }
              }
              // Cancel all over requests
              this._requests.forEach(fn => fn.cancel());
              //const newEsriJson = await 
              this._queryFeatures(this._originalSource.url, request, 0, (cancel) => this._requests.push(cancel), map, displayZoom);
              this._liveLayer = false; // We won't draw the layer again until another tile it requested
          }
          async drawMapData(newEsriJson, displayZoom) {
              // Convert to GeoJSON Features
              const newFeatures = this._esriJsonToFeatures(newEsriJson);
              // Run the diff
              const ids = newFeatures.map(feature => feature.properties[this.promoteId]);
              const updatedIds = await (this._geometriesAtZoom.exec('updateKeysAtZoom')(displayZoom, ids));
              const dataDiff = {
                  add: updatedIds.map((updatedId, idx) => {
                      if (updatedId === 'added') {
                          return newFeatures[idx];
                      }
                  }).filter(idx => idx !== undefined),
                  update: updatedIds.map((updatedId, idx) => {
                      if (updatedId === 'updated') {
                          const geom = newFeatures[idx].geometry;
                          return {
                              id: ids[idx],
                              newGeometry: newFeatures[idx].geometry
                          };
                      }
                  }).filter(idx => idx !== undefined)
              };
              if (dataDiff.update.length || dataDiff.add.length) {
                  if (this.updateData && false) {
                      // TODO Maplibre version 3!
                      // This is untested, so don't enable it!
                      this.updateData(dataDiff);
                  }
                  else {
                      // Update the _data in place
                      const currentFeatures = this._data.features;
                      const currentFeaturesIds = currentFeatures.map(feature => feature.properties[this.promoteId]);
                      // these functions were tested on on jsbench.me, and for loops are the fastest
                      for (let i = 0; i < dataDiff.update.length; i++) {
                          let featureIdx = currentFeaturesIds.indexOf(dataDiff.update[i].id);
                          if (featureIdx > -1) {
                              currentFeatures[featureIdx].geometry = dataDiff.update[i].newGeometry;
                          }
                      }
                      ;
                      for (let i = 0; i < dataDiff.add.length; i++) {
                          currentFeatures.push(dataDiff.add[i]);
                      }
                      this.setData(this._data);
                  }
              }
          }
          async _queryFeatures(url, options, offset, cancel, map, zoom) {
              map = map === undefined ? this.map : map;
              if (map === undefined)
                  throw new Error('Source Data (Source ID: ' + this.id + ') could not be loaded');
              // Convert the out field array to a string
              const outFieldsString = Array.isArray(this._originalSource.outfields) ?
                  this._originalSource.outfields.map(f => `"${f}"`).join(',') :
                  '*';
              const quantizationSting = this._quantizedQuery ?
                  JSON.stringify(quantizationParameters(zoom, this.tileSize)) :
                  '';
              // Define the full query parameters
              const queryParams = {
                  'where': this._options.where,
                  'spatialRel': 'esriSpatialRelIntersects',
                  'outFields': outFieldsString,
                  'returnGeometry': true,
                  'returnTrueCurves': false,
                  // If the data is quantized, quantize it to 3857, otherwise just use 4326
                  // the PBF format is always quantized (even if the coordinates quantization isn't supported)
                  'outSR': (this._quantizedQuery || this._requestFormat === 'pbf') ? '3857' : '4326',
                  'returnIdsOnly': false,
                  'returnCountOnly': false,
                  'returnZ': false,
                  'returnM': false,
                  'returnDistinctValues': false,
                  'returnExtentOnly': false,
                  'featureEncoding': 'esriDefault',
                  'orderByFields': this._sortableFields.map(v => `"${v}"`).join(','),
                  'resultOffset': offset !== undefined ? offset : 0,
                  'resultRecordCount': this._originalSource.resultRecordCount,
                  'quantizationParameters': quantizationSting,
                  //'token': this.token, // TODO
                  'f': this._requestFormat,
                  ...options
              };
              const mapFetch = new MapFetch(map);
              const tmpUrl = new URL(url);
              Object.keys(queryParams)
                  .map(key => tmpUrl.searchParams.append(key, queryParams[key].toString()));
              const dataPromise = mapFetch.fetch(url + '/query', {
                  'body': tmpUrl.search.replace(/^\?/, ''),
                  //'method': 'POST', // Automatically decide based on URL length (GETs have better caching)
                  'headers': {
                      'content-type': 'application/x-www-form-urlencoded'
                  },
              }, (cancelFunction) => cancel && cancel(cancelFunction));
              const arcgisRequest = await (await dataPromise);
              let data = { 'features': [], 'exceededTransferLimit': false };
              try {
                  if (queryParams.f === 'pbf') {
                      const pbfData = await arcgisRequest.arrayBuffer();
                      const convertPbfWorker = createActor('ConvertPbf', [pbfData]);
                      //const convertPbf = new ConvertPbf(pbfData);
                      data = await convertPbfWorker.exec('convert')();
                  }
                  else {
                      data = await arcgisRequest.json();
                      if (this._quantizedQuery) {
                          // Dezigzag simplified data
                          const dezigzagWorker = createActor('DeZigZagJSON', [
                              data.features,
                              data.transform,
                              data.geometryType
                          ]);
                          const features = await dezigzagWorker.exec('convert')();
                          data.spatialReference = { 'wkid': 4326 };
                          data.features = features;
                      }
                  }
              }
              catch (e) {
                  // There was an error with the request, it was probably cancelled
                  if (e !== 'cancel') {
                      console.error('Error with request', e);
                  }
                  return;
              }
              // Update the data
              if (data && data.features.length) {
                  this._events.fire('data', {
                      'json': data,
                      'zoom': zoom
                  });
              }
              if (data.exceededTransferLimit === true) {
                  this._queryFeatures(url, options, (offset || 0) + data.features.length, cancel, map, zoom);
              }
          }
          _esriJsonToFeatures(esriJson) {
              const supportedGeometryTypes = {
                  'esriGeometryPoint': 'Point',
                  'esriGeometryMultipoint': 'MultiPoint',
                  'esriGeometryLine': 'LineString',
                  'esriGeometryPolyline': 'MultiLineString',
                  'esriGeometryPolygon': 'MultiPolygon'
              };
              if (Object.keys(supportedGeometryTypes).indexOf(esriJson.geometryType) === -1) {
                  throw new Error('Geometry ' + esriJson.geometryType + ' not supported');
              }
              // Convert Features
              const features = esriJson.features.map(feature => {
                  // TODO reproject? data should already be 4326 by this point
                  if ((esriJson.spatialReference.latestWkid || esriJson.spatialReference.wkid) !== 4326) {
                      console.warn('Unspported Projection (' + (esriJson.spatialReference.latestWkid || esriJson.spatialReference.wkid) + '), some data may not display correctly');
                  }
                  return {
                      'type': 'Feature',
                      'properties': feature.attributes,
                      'geometry': arcgisToGeoJSON(feature.geometry)
                  };
              });
              return features;
          }
          _waitEvent(name, waitTime = 100) {
              // Uses listeners are a debouncer
              console.log('Called', name, waitTime);
              this._waitTimes[name] = (this._waitTimes[name] || 0) + waitTime;
              setTimeout(() => {
                  if (this._waitTimes[name] !== undefined) {
                      this._waitTimes[name] = this._waitTimes[name] - waitTime;
                      if (this._waitTimes[name] <= 0) {
                          this._waitTimes[name] = 0; // Reset the time to 0
                          this._events.fire(name);
                      }
                  }
              }, waitTime);
          }
      };
  }
  ;

  return ArcGisRestSource;

}));
//# sourceMappingURL=maplibre-gl-arcgis-rest-source.min.js.map
