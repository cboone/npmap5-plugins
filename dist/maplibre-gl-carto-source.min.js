(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.CartoSource = factory());
})(this, (function () { 'use strict';

  const cartoDefaults = {
      'type': 'carto',
      'server': 'carto.com'
  };
  function CartoSource(mapLibrary, options = cartoDefaults) {
      return class CartoSource extends mapLibrary['VectorTileSource'] {
          constructor(id, originalSource, dispatcher, eventedParent) {
              super(id, { 'type': 'vector', 'collectResourceTiming': true }, dispatcher, eventedParent);
              // Set the defaults
              this.id = id;
              this._originalSource = { ...options, ...originalSource };
              // If there is not a SQL query, but there's a table, make the query 'SELECT * FROM {TABLE}'
              if (this._originalSource.table && !this._originalSource.sql) {
                  this._originalSource.sql = `SELECT * FROM "${this._originalSource.user}"."${this._originalSource.table}";`;
              }
              else if (this._originalSource.sql && !this._originalSource.table) {
                  this._originalSource.table = undefined;
              }
              else if (!this._originalSource.sql && !this._originalSource.table) {
                  throw new Error(`${this._originalSource.type} requires either a sql or table parameter`);
              }
          }
          load() {
              this.convertToSource().then(convertedSource => {
                  this.url = convertedSource.url; //
                  this.tiles = convertedSource.tiles; //?: string[] | undefined;
                  this.bounds = convertedSource.bounds; //?: [number, number, number, number] | undefined;
                  this.scheme = convertedSource.scheme; //?: "xyz" | "tms" | undefined;
                  this.minzoom = convertedSource.minzoom; //?: number | undefined;
                  this.maxzoom = convertedSource.maxzoom; //?: number | undefined;
                  this.promoteId = convertedSource.promoteId; //?: PromoteIdSpecification | undefined;
                  super.load();
              });
          }
          async convertToSource() {
              let cartoMapConfig = {
                  version: '1.3.0',
                  layers: [{
                          'type': 'mapnik',
                          'options': {
                              'sql': this._originalSource.sql,
                              'srid': '3857'
                          }
                      }]
              };
              if (this._originalSource.minzoom !== undefined)
                  cartoMapConfig.minzoom = this._originalSource.minzoom.toString();
              if (this._originalSource.maxzoom !== undefined)
                  cartoMapConfig.maxzoom = this._originalSource.maxzoom.toString();
              //if (this.source.bounds) {
              // TODO maplibre only support 4326 and carto wants 3857
              //cartoMapConfig.extent = JSON.stringify(this.source.bounds);
              //}
              let url = new URL(`https://${this._originalSource.server}/user/${this._originalSource.user}/api/v1/map`);
              // carto.com uses a different format than on-prem
              if (this._originalSource.server === 'carto.com') {
                  url = new URL(`https://${this._originalSource.user}.${this._originalSource.server}/api/v1/map`);
              }
              url.searchParams.append('config', JSON.stringify(cartoMapConfig));
              let tileUrls = [];
              try {
                  const resp = await fetch(url);
                  const json = await resp.json();
                  tileUrls = json.metadata.tilejson.vector.tiles;
              }
              catch (e) {
                  throw new Error(`${this._originalSource.type} source failed to load`);
              }
              let maplibrarySource = {
                  ...this._originalSource,
                  ...{
                      'type': 'vector',
                      'tiles': tileUrls
                  }
              };
              return maplibrarySource;
          }
      };
  }
  ;

  return CartoSource;

}));
//# sourceMappingURL=maplibre-gl-carto-source.min.js.map
